;[
minus operator:
, unary: "-x" is equivalent to "x.neg()"
, binary: "x - y" is equivalent to "x.sub(y)"
]

;[
floating point numbers are decimal if supported, otherwise they are binary
	#ifdef __STDC_IEC_60559_DFP__
	_Decimal32, _Decimal64, _Decimal128
for some calculations, the operands must first be casted to 80 bit float, and the result casted back to 64 bits
https://en.wikipedia.org/wiki/Extended_precision
]

Numeric := Ord..String'rep..&
	add: { self :X':Num, other :X' | X' }
	sub:: { self :X', other :X' | :X'
	}
	
	mul: { self :X', other :X' | X' }
	div: { self :X', other :X' | X' }
	pow:: { self :X', other :X' | :X'
	}
	
	is'equal: {}
	is'less: {}
	
	to'string: {}
	
	set:: { self !X' |
		;{ }
	}

Num = &
	next'up: { self | :Num
	}
	
	next'down: { self | :Num
	}
	
	neg: { self :X' | X' }
	
	abs: { self :X' | X' }
	
	cos: { self | :Num
	}
	acos: { self | :Num
	}
	cosh: { self | :Num
	}
	atanh: { self | :Num
	}
	sin: { self | :Num
	}
	asin: { self | :Num
	}
	sinh: { self | :Num
	}
	tan: { self | :Num
	}
	atan: { self | :Num
	}
	atan2: { self | :Num
	}
	tanh: { self | :Num
	}
	
	log: { self | :Num
	}
	log2: { self | :Num
	}
	log10: { self | :Num
	}
	
	e: ; base of the natural logarithm
	pi:
	nan:
	inf:

.. Numeric.
	add: {}
	
	neg: { self | :Num
		;{ return -self }
	}
	
	mul {}
	
	div: {}
	
	pow: {}
	
	is'equal: {}
	
	is'less: {}
	
	to'string: {}

Num's =

Num'l =

Num8 = &
	min: ;{}
	max: ;{}
	
	; bitwise operations
	bit'and: {}
	bit'or: {}
	bit'xor: {}
	bit'neg: {}
	shift'l: {}
	shift'r: {}
	
	; creates a range iterator
	to: { self, rhs :Num8 | :Iter(Num8)
	}
		
	to'num: { self | :Num
		;{ return (double)self }
	}

.. Numeric.
	add: {}
	
	mul: {}
	
	div: {}
	
	pow: {}
	
	is'equal: {}
	
	is'less: {}
	
	to'string: {}

Num4 =

Num2 =

Num1 =
