comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment to mutable variables:
	v .= ...

integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)
floating point numbers: F32, F64

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
mutating arrays:
	a! = [1, 2, 3]
	a.put 0 at: 0 ; [0, 2, 3]
	a.put 4 at: 3 ; [0, 2, 3, 4]
dictionaries are like arrays, but are indexed using strings instead of integers:
	m :Dict(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	m_'a

strings are arrays of "I8" values
they can be written using a UTF8 encoded representation inside double quotes:
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
indexing strings is not really meaningful
thus it's better to split long strings into an array of single'line strings
	'[
		first line
			second line
	]
which is equivalent to:
	["first line", "\tsecond line"]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
alternative syntax: # a: 1 b: 2 c: 3
to access an element:
	r.a
	r.0
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

function:
	f = { a :A , b :B | :C ... }
determining default values for parameters:
	f = { a = 1 | :B ... }
function call:
	f x y
which is equivalent to:
	f(x, y)
postfix syntax (only possible if "x" does not have a field named "f"):
	x .f y
or:
	x.f y

{ f x y } can be written as: \\ f x y

if'else:
	if condition {...} {...}
	if condition {...} \\ if c {...} \\ if c {...} {...}

and or:
	True & False
	True \ False
which are equivalent to:
	True .and {False}
	True .or {False}

matching:
	match a {
		Some. b | ...
		None | ...
	}

loops:
	loop { ... break ... }
	while {condition} { ... }
	for iterator { x | ... }
which is equivalent to:
	iterator.for'each { x | ... }

async function:
	af :Async(A) = { a :A || ... }
actor:
	a = Actor.new B.new(x, y)
	a.do { b :B || ... }

struct:
	S := #
		a: A
		b:: 1 ; field with default value
fields with default values can be made private (by adding an apostrophe at the end of its name)
an instance of a struct:
	i = S. a: x b: y
	i = S. a: x ; using the default value

singletons:
	True := ()
	False := ()
	True = True.()
	False = False.()
unions:
	Bool := True + False
"?A" is a shortcut for "A+None", where "None" is a singleton:
	None := ()
	None = None.()

generic types are written using lower case letters:
	x :x = ...

modules are files containing definitions
any type that its name is the same as the module's name (possibly plus an extension starting with an apostrophe),
	as well as all functions whose first argument is of that type,
	will be exported (ie is accessable outside of the module)
to prevent an export, appent an apostrophe at the end of its name: a' = ...
the file named "0.jina" is the root module
the root module can contain the main function
modules can also be directories containing a root module
to access modules in packages (protocol can be gnunet, git or lib):
	p = package "protocol://address'of'package'directory"
