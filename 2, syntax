comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment to mutable variables:
	v .= ...

integers: Int8, Int16, Int32, Int64, Int (which can be 32 or 64 depending on the system)
floating point numbers: Float32, Float (64 bit)

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
mutating arrays:
	a! = [1, 2, 3]
	a.put 0 at: 0 ; [0, 2, 3]
	a.put 4 at: 3 ; [0, 2, 3, 4]
dictionaries are like arrays, but are indexed using strings instead of integers:
	m :Dict(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	m_'a

strings are arrays of "Int8" values
they can be written using a UTF8 encoded representation inside double quotes:
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
indexing strings is not really meaningful
thus it's better to split long strings into an array of single'line strings
	'[
		first line
			second line
	]
which is equivalent to:
	["first line", "\tsecond line"]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
alternative syntax: & a: 1 b: 2 c: 3
to access an element:
	r.a
	r.0
records can be matched on smaller records:
	a, b = 1, 2, 3
tagged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
or:
	(a: 1, b: 2). c: 3 d: 4
the above behaves like:
	(a: 1, b: 2, c: 3, d: 4)
masking fields:
	(a: 1, b: 2)..(b: 3, c: 4)
which behaves like:
	(a: 1, b: 3, c: 4)

function:
	f = { a :A , b :B | :C ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: || f x y

if'else:
	condition.then {...} {...}
	condition.then {...} || c.then {...} || c.then {...} {...}

and or:
	a && b
	a \\ b
which are equivalent to:
	a .and {b}
	a .or {b}

matching:
	a # {
		b :B | ...
		:None | ...
	}
which is equivalent to:
	{
		b :B | ...
		:None | ...
	} a

loops:
	{condition}.while { ... }
	iterator.for'each { x | ... }

async function:
	af :Async(A) = {| a :A | ... }
actor:
	a = Actor.new B.new(x, y)
	a.do {| b !B | ... }

modules are files containing definitions
any definition whose name is the module's name, with the first letter capitalized,
	and possibly an additional extension (a number or a word starting with an apostrophe)
	will be exported (ie is accessable outside of the module)
to prevent an export, append an apostrophe at the end of its name: a' = ...
to access the definitions in a module which is inside a directory: dir.Definition
in modules inside a directory, to access other modules in parent directories:
	root'.dir.Definition
a package is a directory of modules which can be accessed like this (protocol can be gnunet, git or lib):
	p = package' "protocol://address'of'package'directory"
definitions in "std" package are directly accessable
	this means that "std.Actor" and "Actor" are the same
packages that contain a file named "0.jina" (which must contain the main function) are program packages

classes are records with methods (functions which their first argument is "self"):
	C = &
		a: A
		b:: B. 1 ; field with default value
		new: { a :A |
			C. a
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
private fields (which can't be accessed from outside of the module),
	are indicated by puting an apostrophe at the end of their names
to create a subtype of a class all fields which are not their own subtypes must be masked by a value:
	c = C..(a: x, b: y)
	c = C. a: x b: y
	c = C. a: x ; fields with default values can be omited
	c = C.new a: x
when calling a method, the "self" argument is skiped:
	c.m x

interfaces are records with virtual methods (functions which their first argument is "sub"):
	I = &
		m1: { sub, x :X | Y }
		m2:: { sub! |
			; default implementation
		}
"sub" is a subtype of a subtype of the interface
interface inheritance:
	I3 = I1..I2..& ...
a class that implements some interfaces:
	C :I1..I2 = &
		...
	.. I1.
		...
	.. I2.
		...
generics:
	C = { X | & ... }
generics bound by an interface:
	C = { X :I | & ... }

enums:
	E = &
		A\B
		... ; methods
Boolean:
	Bool = &
		0\1
		...
	Bool'false = Bool. 0
	Bool'true = Bool. 1
"?A" is a shortcut for "A\()"
