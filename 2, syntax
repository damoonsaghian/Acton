comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[
	braket pairs can be nested: []
	to write single brakets, put them in double quotes: "]"
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment to mutable variables:
	v .= ...

integers: Int1, Int4, Int8, Int (which can be 4 bytes or 8 bytes depending on the system)
floating point numbers (8 bytes): Float

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
negative index counts from the end of the array
mutating arrays:
	a! = [1, 2, 3]
	a.put 0 at: 0 ;; [0, 2, 3]
	a.put 4 at: 3 ;; [0, 2, 3, 4]
dictionaries are like arrays, but are indexed using strings instead of integers:
	m :Dict(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	m_'a

strings are arrays of "Int1" values
they can be written using a UTF8 encoded representation inside double quotes:
	s :String = "abc def"
alternative syntax:
	s = '(abc def)
one word string:
	'abc
string interpolation: "abc{x}"
indexing strings is not really meaningful
it's better to split long strings into an array of single'line strings:
	'[
		first line
			second line
	]
which is equivalent to:
	["first line", "\tsecond line"]

records:
	r :(a: Int, b: Int, c: Int) = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
alternative syntax: & a: 1 b: 2 c: 3
to access an element:
	r.a
	r.0
records can be matched on smaller records:
	a, b = 1, 2, 3
tagged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
the above behaves like:
	(a: 1, b: 2, c: 3, d: 4)
masking fields with the same type:
	(a: 1, b: 2)..(b: 3, c: 4)
which behaves like:
	(a: 1, b: 3, c: 4)

function:
	f = { a :A , b :B | :C ... }
note that the type of above function is:
	{ a :A , b :B | C }
this somehow strange type is to avoid contravarient behaviour of function arguments,
	when we introduce interfaces
function call:
	f x y
which is equivalent to:
	f(x, y)
and:
	(x, y) # f

{ f x y } can be written as: || f x y

conditional expression:
	condition.then {...} else: {...}
	condition.then {...} {...}
	condition.then {...} || c.then {...} || c.then {...} {...}

and or:
	a && b
	a \\ b
which are equivalent to:
	a .and {b}
	a .or {b}

matching:
	a # {
		b :B | ...
		() | ...
	}

loop:
	iterator.for'each { x | ... }

async function:
	af = {| a :A | ... }
actor:
	a = Actor.new B.new(x, y)
	a.do {| b !B | ... }

modules are files containing definitions
any definition whose name is the module's name, with the first letter capitalized,
	and possibly an additional extension (a number or a word starting with an apostrophe)
	will be exported (ie is accessable outside of the module)
to prevent an export, append an apostrophe at the end of its name: a' = ...
to access the definitions in a module which is inside a directory: dir.Definition
in modules inside a directory, to access other modules in parent directories:
	root'.dir.Definition
a package is a directory of modules
to use a package in a project, create a ".p" file containing this line (protocol can be gnunet, git or lib):
	protocol://address'of'package'directory
then one can use the modules of the package like this:
	package'filename.Module
definitions in "std" package are directly accessable
	this means that "std.Actor" and "Actor" are the same
packages that contain a file named "0.jina" (which must contain the main function) are program packages

structs:
	S := &
		a: A
		b:: B. 1 ; field with default value
defining methods:
	S = &
		new: { a :A |
			S. a
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
private fields and methods (which can't be accessed from outside of the module),
	are indicated by puting an apostrophe at the end of their names
to create an instance of a struct:
	s :S = a: x, b: y
	s = S. a: x b: y
	s = S. a: x ; fields with default values can be omited
	s = S.new a: x
calling a method:
	s.m x
which is equivalent to:
	S.m s x
this implies that to call a field that is a function, we have to use parentheses: (r.f)(x)

generics:
	S := a: X', b: X'
bounded generics:
	S := a: X' :I, b: X'

singletons:
	Bool'true' := ()
	Bool'true = Bool'true. ()
	Bool'false' := ()
	Bool'false = Bool'false. ()
unions:
	Bool := Bool'true \ Bool'false
type "?A" is a shortcut for "A\()"

interfaces:
	I := &
		m1: { self :A', x :X | Y }
		m2:: { self !A' |
			; default implementation
		}
interface inheritance:
	I3 := I1..I2..& ...
defining the methods of a struct that implements some interfaces:
	S = &
		...
	.. I1.
		...
	.. I2.
		...

to enter C code: '{...}
