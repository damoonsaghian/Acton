comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment to mutable variables:
	v .= ...

integers: Int8, Int16, Int32, Int64, Int (which can be 32 or 64 depending on the system)
floating point numbers: Float32, Float (64 bit)

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
mutating arrays:
	a! = [1, 2, 3]
	a.put 0 at: 0 ; [0, 2, 3]
	a.put 4 at: 3 ; [0, 2, 3, 4]
dictionaries are like arrays, but are indexed using strings instead of integers:
	m :Dict(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	m_'a

strings are arrays of "Int8" values
they can be written using a UTF8 encoded representation inside double quotes:
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
indexing strings is not really meaningful
thus it's better to split long strings into an array of single'line strings
	'[
		first line
			second line
	]
which is equivalent to:
	["first line", "\tsecond line"]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
alternative syntax: & a: 1 b: 2 c: 3
to access an element:
	r.a
	r.0
records can be matched on smaller records:
	a, b = 1, 2, 3
tagged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
the above behaves like:
	(a: 1, b: 2, c: 3, d: 4)
masking fields with the same type:
	(a: 1, b: 2)..(b: 3, c: 4)
which behaves like:
	(a: 1, b: 3, c: 4)

function:
	f = { a :A , b :B | :C ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: || f x y

if'else:
	condition.then {...} else: {...}
	condition.then {...} {...}
	condition.then {...} || c.then {...} || c.then {...} {...}

and or:
	a && b
	a \\ b
which are equivalent to:
	a .and {b}
	a .or {b}

matching:
	a # {
		b :B | ...
		() | ...
	}
which is equivalent to:
	{
		b :B | ...
		() | ...
	} a

loop:
	iterator.for'each { x | ... }

async function:
	af = {| a :A | ... }
actor:
	a = Actor.new B.new(x, y)
	a.do {| b !B | ... }

modules are files containing definitions
any definition whose name is the module's name, with the first letter capitalized,
	and possibly an additional extension (a number or a word starting with an apostrophe)
	will be exported (ie is accessable outside of the module)
to prevent an export, append an apostrophe at the end of its name: a' = ...
to access the definitions in a module which is inside a directory: dir.Definition
in modules inside a directory, to access other modules in parent directories:
	root'.dir.Definition
a package is a directory of modules which can be accessed like this (protocol can be gnunet, git or lib):
	p = package' "protocol://address'of'package'directory"
definitions in "std" package are directly accessable
	this means that "std.Actor" and "Actor" are the same
packages that contain a file named "0.jina" (which must contain the main function) are program packages

structs:
	S := &
		a: A
		b:: B. 1 ; field with default value
defining methods:
	S = &
		new: { a :A |
			S. a
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
private fields and methods (which can't be accessed from outside of the module),
	are indicated by puting an apostrophe at the end of their names
to create an instance of a struct:
	s :S = a: x, b: y
	s = S. a: x b: y
	s = S. a: x ; fields with default values can be omited
	s = S.new a: x
calling a method:
	s.m x
which is equivalent to:
	S.m s x
this implies that to call a field that is a function, we have to use parentheses: (r.f)(x)

interfaces:
	I := &
		m1: { self, x :X | Y }
		m2:: { self! |
			; default implementation
		}
interface inheritance:
	I3 := I1..I2..& ...
defining the methods of a struct that implements some interfaces:
	S = &
		...
	.. I1.
		...
	.. I2.
		...

generics:
	S := a: X', b: X'
bounded generics:
	S := a: X' :I, b: X'

singletons:
	Bool'true' := ()
	Bool'true = Bool'true. ()
	Bool'false' := ()
	Bool'false = Bool'false. ()
unions:
	Bool := Bool'true \ Bool'false
type "?A" is a shortcut for "A\()"
