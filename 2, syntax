comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment blocks:
	;; comment ;;
	;; multi'line
	comment
	;;

variable definition:
	v = ...
type annotation:
	v :: T = ...

integers: I32, I64
floating point numbers: F32 F64

box:
	b :: !I32 = !1
mutate the data in box:
	b .set 2

strings are immutable UTF8 encoded, excluding the new line character
UTF8 strings:
	s :: String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
array of strings:
	'[
	line1
	line2
	]
which is equivalent to:
	["line1", "line2"]

array:
	a = [1, 2, 3]
empty array:
	a = Array(Int).new()
indexing:
	a_1
map:
	['a : 1, 'b : 2, 'c : 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
empty map:
	x = Map(String, Int).new()

records:
	r = (a: 1, b: 2, c: 3)
	r = (1, 2, c: 3)
to access an element:
	r.a
	r.1
to change an element:
	r.a = 2
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
if the second operand is a literal record (ie not a variable), this can also be written as:
	(a: 1, b: 2).(c: 3, d: 4)
	(a: 1, b: 2). c: 3 d: 4
the above value behaves like (but is not exactly the same as):
	(a: 1, b: 2, c: 3, d: 4)
common fields are possible if the new field is a subtype of the old one (which will be masked):
	(a: Int, b: 2)..(a: 3) ;; behaves like (a: 3, b: 2) ;;

function:
	f = { a :: A, b :: B -> ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{f x y} can be written as: | f x y

if'else:
	if condition {...} {...}
	if condition {...} | if c {...} {...} | if c {...} {...}
and or:
	True .and {False}
	True .or {False}
matching:
	match a {
		b :: B -> ...
		None -> ...
	}

loops:
	loop {...break...}
while {condition} { ... }
	for iterator { x -> ... }
which is equivalent to:
	iterator .for'each { x -> ... }

modules are files containing definitions
to make a definition private, append an apostrophe to the end of its name
the file named "0" is the root module
the root module can contain the main function
to import definitions from other modules:
	C', f' = import "module/path/relative/to/current/directory"
	C: D', f' = import "module/path/relative/to/current/directory"
	m' = import "/module/path/relative/to/project/root"
	m' = import "//hostname/package name including major version/module/path"

enum:
	Bool = True + False
"C?" is a shortcut for "C + None"

class:
	C = (
		a: A,
		b: B,
		new: { a :: A -> :: C
			b = ...
			C. a: a b: b
		}
		m: { self :: C, x :: X -> :: Y
			...
		}
	)
creating an instance:
	i = C. a: x b: y
calling a method:
	i .m x
which is equivalent to:
	i.m i x

subclassing:
S = C.(e: E)

generics:
G = { p :: P -> a: p, b: B }

actors:
a = Actor.new B.(x, y)
a .do { b :: B -> ... }
