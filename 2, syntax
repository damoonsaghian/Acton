comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...

integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)
floating point numbers: F32, F64

box:
	b : !I32 = !1
mutate the data in a box:
	b.set 2
note that !T is a subtype of T, so all operation for T is also valid on !T

strings are immutable, and encoded in UTF8
	s : String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
array of strings:
	'[
	line1
	line2
	]
which is equivalent to:
	["line1", "line2"]

array:
	a : Array(Int) = [1, 2, 3]
indexing:
	a_1
maps are like arrays, but indexed using strings instead of integers:
	m : Map(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
mutable array/map:
	a : Array!(Int) = ![1, 2, 3]

records:
	r = a: 1, b: 2, c: 3
	r = 1, 2, c: 3
to access an element:
	r.a
	r.1
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

function:
	f : Func (A, B) C = { a : A, b : B | C :: ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: \\ f x y

if'else:
	if condition {...} {...}
	if condition {...} \\ if c {...} \\ if c {...} {...}

and or:
	True & False
	True \ False
which are equivalent to:
	True .and {False}
	True .or {False}

matching:
	match a {
		b : B | ...
		() | ...
	}

loops:
	loop { ... break ... }
	while {condition} { ... }
	for iterator { x | ... }
which is equivalent to:
	iterator.for'each { x | ... }

async function:
	af : Async A = { a : A || ... }
actor:
	a = Actor.new B. (x, y)
	a.do { b : B || ... }

modules are files containing definitions
to make a definition private, append an apostrophe to the end of its name
the file named "0" is the root module
the root module can contain the main function
to import definitions from other modules:
	A', a' = import "module/path/relative/to/current/directory"
	A: B', a' = import "module/path/relative/to/current/directory"
	m' = import "/module/path/relative/to/project/root"
	m' = import "//hostname/package name including major version/module/path"

module extension:
	.{ a = 1; b = 2 }.{ c = 3; d = 4 }
the above value behaves like:
	.{ a = 1; b = 2; c = 3; d = 4 }
module instance:
	.{ a : Int; b = 2 }.(a: 1)
which can also be written as:
	.{ a : Int; b = 2 }. a: 1

undefined symbols begining with a capital letter (eg True and False), are their own subtype (like literals)
enum:
	Bool = [True, False]
"?A" is a shortcut for "[A, ()]"

classes are self referntial modules:
	C = .{
		a : A
		b : B
		new = { a : A | Self ::
			b = ...
			Self. a: a b: b
		}
		m = { self, x : X | Y ::
			...
		}
	}
creating an instance:
	i = S.new a: x
	i = S. a: x b y
when calling a method, the "self" argument is skiped:
	i.m x

interface:
	I = .{
		m1 : Func (I, X) Y
		m2 = {...}
	}
as you see (for m2) default methods are supported too
implementing an interface:
	C = (I1 + I2).{...}

generics:
	C = .{ X : () | ... }
generics bound by an interface:
	C = { X : I | ... }
