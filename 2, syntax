comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment blocks:
	;; comment ;;
	;; multi'line
	comment
	;;

variable definition:
	v = ...
type annotation:
	v :: T = ...

integers: I32, I64
writing an I32 in character form:
	\a

UTF8 strings:
	s :: String = "abc def"
one word strings:
	'abc
string interpolation: "abc{x}"
mutable string:
	s :: !String = !"abc def"

array:
	a = [1, 2, 3]
empty array:
	a = Array(Int).new()
indexing:
	a_1
map:
	['a : 1, 'b : 2, 'c : 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
empty map:
	x = Map(String, Int).new()
mutable array and map:
	a :: !Array(Int) = ![1, 2, 3]
	m :: !Map(String, Int) = ![a: 1, b: 2, c: 3]

records:
	r = (a: 1, b: 2, c: 3)
	r = (1, 2, c: 3)
to access an element:
	r.a
	r.1
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutable record:
	r :: !(Int, Int) = !(1, 2)
to change an element:
	r.a = 2

note that !T is a subtype of T

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
the above value behaves like (but is not equal to):
	(a: 1, b: 2, c: 3, d: 4)
if the field already exists, and if the new field is a subtype of it, it will be masked:
	(a: Int, b: 2)..(a: 3) ;; behaves like (a: 3, b: 2) ;;
if the second operand is a literal record, these three expressions are equivalent:
	(a: 1, b: 2)..!(c: 3, d: 4)
	(a: 1, b: 2).(c: 3, d: 4)
	(a: 1, b: 2). c: 3 d: 4

function:
	f = { a :: A, b :: B -> ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

I32 and I64 will always be copied between variable
immutable types: copy small ones, reference big ones
inside a function, variable captured from outside:
, all mutable parts will be copied
, if the lifetimes can't be computed statically, they will be copied

{f x y} can be written as: | f x y

if'else:
	if condition {...} {...}
	if condition {...} | if c {...} {...} | if c {...} {...}
and or:
	True .and {False}
	True .or {False}
matching:
	match a {
		Some b -> ...
		None -> ...
	}

loops:
	loop {...break...}
while {condition} { ... }
	for iterator { x -> ... }
which is equivalent to:
	iterator.for'each { x -> ... }

modules are files containing definitions
to make a definition private, append an apostrophe to the end of its name
the file named "0" is the root module
the root module can contain the main function
to import definitions from other modules:
	C', f' = import "module/path/relative/to/current/directory"
	C: D', f' = import "module/path/relative/to/current/directory"
	m' = import "/module/path/relative/to/project/root"
	m' = import "//hostname/package name including major version/module/path"

enum:
	Bool = True + False
"C?" is a shortcut for "C + None"

class:
	C = (
		a: A,
		b: B,
		new: { a :: A -> :: C
			b = ...
			C. a: a b: b
		}
		m: { self :: C, x :: X -> :: Y
			...
		}
	)
creating an instance:
	i = C. a: x b: y
calling a method:
	i .m x
which is equivalent to:
	i.m i x

subclassing:
D = C..(e: E)

generics:
C = { t :: D -> a: t, b: B }

actors:
a = Actor.new B.(x, y)
a .do { b :: !B -> ... }
