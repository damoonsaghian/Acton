comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment blocks:
	;; comment ;;
	;; multi'line
	comment
	;;

variable definition:
	v = ...
type anotation:
	v :: T = ...

UTF8 character:
	\a
	\0000
UTF8 string:
	"abc def"
one word string:
	'abc
string interpolation: "abc{x}"

array:
	[1, 2, 3]
empty array:
	x :: Array(Int) = []
indexing:
	x_1
maps:
	['a : 1, 'b : 2, 'c : 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
empty map:
	x :: Map(String, Int) = []

records:
	r = (a: 1, b: 2, c: 3)
	r = (1, 2, c: 3)
to access an element:
	r.a
	r.1
to change an element:
	r.a = 2
records can be matched on sub'records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
which can also be written as:
	(a: 1, b: 2) .. c: 3 d: 4
the above value behaves like (but is not equal to):
	(a: 1, b: 2, c: 3, d: 4)
if the field already exists, and if it's a subtypes, the old value will be masked:
	(a: Int, b: 2)..(a: 3) ;; behaves like (a: 3, b: 2) ;;
note that we can only mutate the fields of extention part (and not the base part)

function:
	f = { a :: A, b :: B -> ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{f x y} can be written as: | f x y

if'else:
	if condition {...} {...}
	if condition {...} | if c {...} {...} | if c {...} {...}
and or:
	True .and {False}
	True .or {False}
matching:
	match a {
		Some b -> ...
		None -> ...
	}

loops:
	loop {...break...}
while {condition} { ... }
	for iterator { x -> ... }
which is equivalent to:
	iterator.for'each { x -> ... }

actors:
a = Actor B(x)
a .do { b -> ... }

modules are files containing definitions
to make a definition private, append an apostrophe to the end of its name
the file named "0" is the root module
the root module can contain the main function
to import definitions from other modules:
	C', f' = import "module/path/relative/to/current/directory"
	C: D', f' = import "module/path/relative/to/current/directory"
	m' = import "/module/path/relative/to/project/root"
	m' = import "//hostname/package name including major version/module/path"

types are first class values

enum:
	Bool = True + False
"C?" is a shortcut for "C + None"

class:
	C = (
		a: A,
		b: B,
		new: { a :: A -> :: C
			b = ...
			C .. a: a b: b
		}
		m: { self :: C, x :: X -> :: Y
			...
		}
	)
creating an instance:
	i = C .. a: x b: y
calling a method:
	i .m x
which is equivalent to:
	i.m i x

subclassing:
D = C .. e: E

generics:
C = { t :: D -> a: t, b: B }
