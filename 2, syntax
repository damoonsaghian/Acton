comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...

integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)
floating point numbers: F32, F64

strings are immutable, and encoded in UTF8
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"

box:
	b :!I32 = !1
mutate the data in a box:
	b.set 2
note that !T is a subtype of T, so all operation for T is also valid on !T

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
maps are like arrays, but indexed using strings instead of integers:
	m :Map(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
mutable array/map:
	a :Array!(Int) = ![1, 2, 3]

array of strings:
	'[
		line1
			line2
	]
which is equivalent to:
	["line1", "\tline2"]
mutable variant: !'[]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
to access an element:
	r.a
	r.1
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

function:
	f :Func (A, B) C = { a :A , b :B | :C ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: \\ f x y

if'else:
	if condition {...} {...}
	if condition {...} \\ if c {...} \\ if c {...} {...}

and or:
	True & False
	True \ False
which are equivalent to:
	True .and {False}
	True .or {False}

matching:
	match a {
		B. b | ...
		() | ...
	}

loops:
	loop { ... break ... }
	while {condition} { ... }
	for iterator { x | ... }
which is equivalent to:
	iterator.for'each { x | ... }

async function:
	af :Async(A) = { a :A || ... }
actor:
	a = Actor.new B.new(x, y)
	a.do { b :B || ... }

modules are files containing definitions
to make a definition private, append an apostrophe to the end of its name
the file named "0" is the root module
the root module can contain the main function
to access a module, just use its path relative to the directory containing the root module:
	m' = ..file'name
	m' = .."dir/file'name"
too access modules in packages (protocol can be gnunet, git or local):
	m' = .."protocol://address'of'project'dir//major'version/dir/file"

singletons are like empty modules:
	True = .{}
	False = .{}
enums:
	Bool = True .. False
"?A" is a shortcut for "A..()"

classes are like modules, but they can have unimplemented definitions
we create instances of a class, by implementing all those definitions
	C = .{
		a :A
		b :B
		new = { a :A | :Self
			b = ...
			Self. a: a b: b
		}
		m = { self, x :X | :Y
			...
		}
	}
note that all methods (functions with "self" arg) must be implemented, otherwise instances can't be created
creating an instance of a class:
	i = S.new a: x
	i = S.(a: x, b: y)
	i = S. a: x b: y
when calling a method, the "self" argument is skiped:
	i.m x

class extension:
	.{ a = 1; b = 2 }..{ c = 3; d = 4 }
the above behaves like:
	.{ a = 1; b = 2; c = 3; d = 4 }
masking common definitions is possible if the types match

interfaces are like classes, but they can have unimplemented methods (and thus can't have instances):
	I = ..{
		m1 : Func (Self, X) Y
		m2 = {...}
	}
interface inheritance:
	I3 = I1..I2..{}

a class that implements some interfaces:
	C :I1..I2 = {...}
note that classes can't be subtypes of other classes
	because to create a subtype, all unimplemented definitions must be implemented

generics:
	C = .{ X | ... }
generics bound by an interface:
	C = .{ X :I | ... }
