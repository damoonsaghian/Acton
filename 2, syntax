comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment to mutable variables:
	v .= ...

integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)
floating point numbers: F32, F64

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
mutating arrays:
	a! = [1, 2, 3]
	a.put 0 at: 0 ; [0, 2, 3]
	a.put 4 at: 3 ; [0, 2, 3, 4]
dictionaries are like arrays, but are indexed using strings instead of integers:
	m :Dict(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	m_'a

strings are arrays of "I8" values
they can be written using a UTF8 encoded representation inside double quotes:
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
indexing strings is not really meaningful
thus it's better to split long strings into an array of single'line strings
	'[
		first line
			second line
	]
which is equivalent to:
	["first line", "\tsecond line"]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
alternative syntax: # a: 1 b: 2 c: 3
to access an element:
	r.a
	r.0
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

function:
	f = { a :A , b :B | :C ... }
determining default values for parameters:
	f = { a = 1 | :B ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: \\ f x y

if'else:
	if condition {...} {...}
	if condition {...} \\ if c {...} \\ if c {...} {...}

and or:
	True & False
	True \ False
which are equivalent to:
	True .and {False}
	True .or {False}

matching:
	match a {
		Some. b | ...
		None | ...
	}

loops:
	loop { ... break ... }
	while {condition} { ... }
	for iterator { x | ... }
which is equivalent to:
	iterator.for'each { x | ... }

async function:
	af :Async(A) = { a :A || ... }
actor:
	a = Actor.new B.new(x, y)
	a.do { b :B || ... }

struct:
	S := #
		a: A
		b:: 1 ; field with default value
defining methods:
	S = #
		new: { b :Int | :S
			a = ...
			S. a b
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
an instance of a struct:
	i = S. a: x b: y
	i = S. a: x ; using the default value

singletons:
	True := ()
	False := ()
	True = True.()
	False = False.()
unions:
	Bool := True + False
"?A" is a shortcut for "A+None", where "None" is a singleton:
	None := ()
	None = None.()

interfaces:
	i := #
		m1: Func (self, x: X) Y
		m2:: { self! |
			; default implementation
		}
interface inheritance:
	i3 := i1*i2*# ...

implementing interfaces:
	S :i1*i2 = # ...

generic types have an apostrophe at the end of their names:
	x :x' = ...

modules are files containing definitions
any definition (type or value) whose name is the same as the module's name,
	or the moduls's name plus an extension (that starts with an apostrophe)
	will be exported (ie is accessable outside of the module)
to prevent an export, append an apostrophe at the end of its name: a' = ...
to access the definitions in a module which is inside a directory: dir.definition
a package is a directory of modules which can be accessed like this (protocol can be gnunet, git or lib):
	p = package "protocol://address'of'package'directory"
definitions in "std" package are directly accessable
	this means that "std.Actor" and "Actor" are the same
packages that contain a file named "0.jina" (which must contain the main function) are program packages
