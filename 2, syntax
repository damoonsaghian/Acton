single'line comment:
	; comment
multi'line comment:
	;
	multi'line
	comment
	;
or:
	;; multi'line
	comment
	;

variable definition:
	v = ...
type anotation:
	v :T = ...

symbols:
	'symbol
symbols are actually their own types:
	's :'s
a string is an array of UTF-8 symbols, and can be written as:
	"abc"
string interpolation: "abc{x}"

arrays:
	[1, 2, 3]
empty array:
	x :[Int] = []
indexing:
	x_1
maps with symbols as keys:
	[a: 1, b: 2, c: 3]
maps with variables as keys:
	[a : 1, b : 2, c : 3]
empty map:
	x :[Char, Int] = []

tuple:
	t = (1, 2, 3)
to access an element:
	t.1
tuples can be matched on sub'tuples:
	a, b = 1, 2, 3
named tuples:
	nt = (a: 1, b: 2, c: 3)
to access an element:
	nt.a
named tuples can be matched on tuples if the name of variables match:
	a, b = a: 1, b: 2

structs are like taged tuples:
	s = 's(a: 1, b: 2)
which can also be written as:
	s = 's a: 1 b: 2
note that type of "s" is:
	:'s(a: Int, b: Int)
accessing elements is like in tuples:
	s.a

function:
	f = { a :A, b :B -> ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{f x y} can be written as: | f x y

if'else:
	if condition {...} {...}
	if condition {...} | if c {...} {...} | if c {...} {...}
and or:
	'true .and {'false}
	'true .or {'false}
matching:
	match a {
		's b -> ...
		'nil -> ...
	}

loops:
	loop {...break...}
while {condition} { ... }
	for iterator { x -> ... }
which is equivalent to:
	iterator.for'each { x -> ... }

actors:
a = Actor B(x)
a.do { b -> ... }

modules are files containing definitions
to make a definition private, append an apostrophe to the end of its name
the file named "0" is the root module
the root module can contain the main function
to import definitions from other modules:
	m' = import "module/path/relative/to/current/directory"
	C', f' = m
	x' = m.y
	m' = import "/module/path/relative/to/project/root"
	m' = import "//hostname/package name including major version/module/path"

type alias:
	T := (T1, T2)
enums:
	Bool := 'true + 'false
"C?" is a shortcut for "C + 'nil"

struct alias:
	S := 's(a: A, b: B)
defining methods:
	S = (
		new: { a :A -> :S
			b = ...
			's(a: a, b: b)
		},
		m: { self :S, x :X ->
			...
		}
	)
creating an instance:
	i = S.new x
or:
	i = 's a: x b: y
calling a method:
	i .m x
which is equivalent to:
	S.m i x

generic struct alias:
	S(t) := 's(a: t, b: B)
interfaces:
	I := (
		m1: (I, A) -> B,
		m2: I -> C
	)
defining methods of the struct alias "S" which implements interfaces "I1" and "I2":
	S :: I1 + I2 = ...
