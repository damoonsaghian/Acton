comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment to mutable variables:
	v .= ...

integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)
floating point numbers: F32, F64

strings are immutable, and encoded in UTF8
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
maps are like arrays, but indexed using strings instead of integers:
	m :Map(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]

array of strings:
	'[
		line1
			line2
	]
which is equivalent to:
	["line1", "\tline2"]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
to access an element:
	r.a
	r.0
alternative syntax: # a: 1 b: 2 c: 3
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

function:
	f = { a :A , b :B | :C ... }
determining default values for parameters:
	f = { a = 1 | :B ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: \\ f x y

if'else:
	if condition {...} {...}
	if condition {...} \\ if c {...} \\ if c {...} {...}

and or:
	True & False
	True \ False
which are equivalent to:
	True .and {False}
	True .or {False}

matching:
	match a {
		Some. b | ...
		None | ...
	}

loops:
	loop { ... break ... }
	while {condition} { ... }
	for iterator { x | ... }
which is equivalent to:
	iterator.for'each { x | ... }

async function:
	af :Async(A) = { a :A || ... }
actor:
	a = Actor.new B.new(x, y)
	a.do { b :B || ... }

modules are files containing definitions
private definition are not accessable from outside of the module: a' = ...
the file named "0.jina" is the root module
the root module can contain the main function
packages are directories containing a root module
to access a module or a package, just use its path relative to the package directory:
	m' = ..module'or'package
	m' = .."dir/module'or'package"
too access modules in packages (protocol can be gnunet, git or lib):
	m' = .."protocol://address'of'project'dir/dir/file"

structs:
	S := #
		a: A
		b:: 1 ; field with default value
defining methods:
	S = #
		new: { b :Int | :S
			a = ...
			S. a b
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
an instance of a struct:
	i = S. a: x b: y
	i = S. a: x ; using the default value
	i = S.new b: y
when calling a method, the "self" argument is skiped:
	i.m x

singletons:
	True := ()
	False := ()
	True = True.()
	False = False.()
unions:
	Bool := True + False
"?A" is a shortcut for "A+None", where "None" is a singleton:
	None := ()
	None = None.()

interfaces:
	I := #
		m1: Func (self, x: X) Y
		m2:: { self! |
			; default implementation
		}
interface inheritance:
	I3 = I1*I2*# ...

implementing interfaces:
	S :I1*I2 = # ...

generics:
	G := X | # ...
generics bound by an interface:
	G := X :I | # ...
