comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[
	braket pairs can be nested: []
	to write single brakets, put them in double quotes: "]"
	]

variable definition (unique by default):
	v :T = ...
	v = ...
immutable and mutable referece counted variables:
	v ::T = ...
	v !:T = ...
mutating mutable variables (unique variables are mutable too):
	v .= ...

integers: Int (mapped to "int" in C), Int8 (mapped to "signed char" in C), Int'c (mapped to "char" in C)
integer notations:
	123'456'789 ;; easier to read
	0b101010 ;; binary
	0o76543210 ;; octal
	0h90abcdef ;; hexadecimal
	'a' :Int'c ;; ASCII character "a"
	'\n' ;; ASCII escape character "\n"
floating point numbers: Float (mapped to "double" in C)

note that in Jina minus sign is a unary operator
there is no "x - y"; instead write "x + -y"
"-x" is equivalent to "x.neg()"

lists:
	l :List(Int) = [1, 2, 3]
indexing:
	l_1
negative indices count from the end of the list
mutating lists:
	l! = [1, 2, 3]
	l.put 0 index: 0 ;; [0, 2, 3]
	l.put 4 index: 3 ;; [0, 2, 3, 4]

strings are lists of "Int'c" values
they can be written using a UTF8 encoded representation inside double quotes:
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
indexing strings is not really meaningful
it's better to split long strings into a list of single'line strings:
	""
	first line
		second line
	""
which is equivalent to:
	["first line", "\tsecond line"]

dictionaries are indexed using strings (instead of integers as in lists):
	d :Dict(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	d_'a

records:
	r :(a: Int, b: Int, c: Int) = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
alternative syntax: & a: 1 b: 2 c: 3
to access an element:
	r.a
	r.0
records can be matched on smaller records:
	a, b = 1, 2, 3
tagged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2
mutating a record:
	r.a = 10

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
the above behaves like:
	(a: 1, b: 2, c: 3, d: 4)
masking fields with the same type:
	(a: 1, b: 2)..(b: 3, c: 4)
which behaves like:
	(a: 1, b: 3, c: 4)

function:
	f = { a :A , b !B | :C ... }
note that the type of above function is:
	f :{ a :A , b !B | C }
this somehow strange type is to avoid contravarient behaviour of function arguments, when we introduce interfaces
function call:
	f x y
which is equivalent to:
	f(x, y)
and:
	(x, y) # f

{ f x y } can be written as: || f x y

conditional expression:
	condition.then {...} else: {...}
	condition.then {...} {...}
	condition.then {...} || c.then {...} || c.then {...} {...}

and or:
	a && b
	a \\ b
which are equivalent to:
	a .and {b}
	a .or {b}
not:
	-a

matching:
	a # {
		b :B | ...
		() | ...
	}

actor:
	a = Actor.new B.new(x, y)
	a.do { b !B | ... }

iterators:
	iter.each { x | ... }

modules are files containing definitions
any definition whose name is the module's name, with the first letter capitalized,
	and possibly an additional extension (a number or a word starting with an apostrophe)
	will be exported (ie is accessable outside of the module)
other definitions are accessable through the module's name: module'name.definition
to hide the internals of a definition, append an apostrophe at the end of its name: a' = ...
to access the definitions in a module which is inside a directory: dir.Definition

a package is a directory of modules
to use a package in a project, create a ".p" file
".p" files contain URL lines (protocol can be gnunet, git or lib):
	protocol://address'of'package'directory
URL line will be tried in the given order, until one is available
if the protocol is git or gnunet, the following line must contain a public key,
	will be used to check the given signature
to use the a module inside a package:
	package'file'name.Module
definitions in "std" package are directly accessable; there is no need for a ".p" file
packages that contain a file named "0.jina" (which must contain the init function) are program packages

structs:
	S := &
		a: A
		b:: B. 1 ; field with default value
defining methods:
	S = &
		new: { a :A |
			S. a
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
private fields and methods (which can't be accessed from outside of the module),
	are indicated by puting an apostrophe at the end of their names
to create an instance of a struct:
	s :S = a: x, b: y
	s = S. a: x b: y
	s = S. a: x ; fields with default values can be omited
	s = S.new a: x
calling a method:
	s.m x
which is equivalent to:
	S.m s x
this implies that to call a field that is a function, we have to use parentheses: (r.f)(x)

generics:
	S := a: X', b: X'
bounded generics:
	S := a: X':I, b: X'

singletons:
	Bool'true' := ()
	Bool'true = Bool'true. ()
	Bool'false' := ()
	Bool'false = Bool'false. ()
unions:
	Bool := Bool'true \ Bool'false
type "?A" is a shortcut for "A\()"

interfaces:
	I := &
		m1: { self :A', x :X | Y }
		m2:: { self !A' |
			; default implementation
		}
interface inheritance:
	I3 := I1..I2..& ...
defining the methods of a struct that implements some interfaces:
	S = &
		...
	.. I1.
		...
	.. I2.
		...

to directly enter C code:
	;{...}
beware: with great power comes great resposibility
