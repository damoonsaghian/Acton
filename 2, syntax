comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment:
	v .= ...

integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)
floating point numbers: F32, F64

strings are immutable, and encoded in UTF8
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
maps are like arrays, but indexed using strings instead of integers:
	m :Map(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]

array of strings:
	'[
		line1
			line2
	]
which is equivalent to:
	["line1", "\tline2"]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
to access an element:
	r.a
	r.0
alternative syntax: # a: 1 b: 2 c: 3
records can be matched on smaller records:
	a, b = 1, 2, 3
taged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
or:
	(a: 1, b: 2). (c: 3, d: 4)
the above behaves like:
	(a: 1, b: 2, c: 3, d: 4)
masking fields:
	(a: 1, b: 2). (b: 3, c: 4)
which behaves like:
	(a: 1, b: 3, c: 4)

function:
	f = { a :A , b :B | :C ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: \\ f x y

if'else:
	if condition {...} {...}
	if condition {...} \\ if c {...} \\ if c {...} {...}

and or:
	True & False
	True \ False
which are equivalent to:
	True .and {False}
	True .or {False}

matching:
	match a {
		Some. b | ...
		None | ...
	}

loops:
	loop { ... break ... }
	while {condition} { ... }
	for iterator { x | ... }
which is equivalent to:
	iterator.for'each { x | ... }

async function:
	af :Async(A) = { a :A || ... }
actor:
	a = Actor.new B.new(x, y)
	a.do { b :B || ... }

modules are files containing definitions
public definition are accessable from outside of the module: a' = ...
the file named "0.jina" is the root module
the root module can contain the main function
packages are directories containing a root module
to access a module or a package, just use its path relative to the package directory:
	m = ..module'or'package
	m = .."dir/module'or'package"
too access modules in packages (protocol can be gnunet, git or local):
	m = .."protocol://address'of'project'dir/dir/file"

class are records with methods (functions which their first argument is "self"):
	C = #
		a: A
		b:: B. 1 ; field with default value
		new: { a :A | :C
			b = ...
			a: a, b: b
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
to make a field private, put an apostrphe at the start of its name
to create a subtype of a class all fields which are not their own subtypes must be masked by a value:
	i = S..(a: x, b: y)
	i = S. a: x b: y
	i = S.new a: x
when calling a method, the "self" argument is skiped:
	i.m x

interfaces:
	I = #
		m1: Func (self, x: X) Y
		m2: ::{ self! |
			; default implementation
		}
interface inheritance:
	I3 = I1. I2. # ...

a class that implements some interfaces:
	C :I1..I2 = # ...
to implement an interface privately:
	C :I' = # ...

Jina uses composition instead of inheritance
thus in Jina, a GObject class translates to a (final) class "G" plus an interface "G'i"
the interface contains all the instance methods of the corresponding GObject class, plus a "base" method
	base = { self | :G ... }
to implement "G'i":
	C :G'i = #
		base'field: G
		...
		base: { self | :G self.base'field }
		...
if the first field is of type "G", the "base" method will be automatically generated,
	no need to write it manually

generics:
	C = { X | ... }
generics bound by an interface:
	C = { X :I | ... }

enums:
	Bool = #
		True: Bool. 'true
		False: Bool. 'false
		...
	True = Bool.True
	False = Bool.False
"?A" is a shortcut for "Maybe(A)":
	Maybe = { X | #
		Some: Maybe(X). 'some X
		None: Maybe(X). 'none
		...
	}
	Some = { X | Maybe(X).Some }
	None = { X | Maybe(X).None }
