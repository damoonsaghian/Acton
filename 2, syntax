comment line (";" must be the first non'whitespace charactor on the line):
	; comment
comment at the end of a line:
	;; comment
comment block:
	;[comment]
	;[multi'line
	comment
	]

variable definition:
	v = ...
type annotation:
	v : T = ...
	v :T = ...
mutable variable:
	v !T = ...
	v! = ...
assignment to mutable variables:
	v .= ...

integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)
floating point numbers: F32, F64

array:
	a :Array(Int) = [1, 2, 3]
indexing:
	a_1
mutating arrays:
	a! = [1, 2, 3]
	a.put 0 at: 0 ; [0, 2, 3]
	a.put 4 at: 3 ; [0, 2, 3, 4]
dictionaries are like arrays, but are indexed using strings instead of integers:
	m :Dict(Int) = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	m_'a

strings are arrays of "I8" values
they can be written using a UTF8 encoded representation inside double quotes:
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
indexing strings is not really meaningful
thus it's better to split long strings into an array of single'line strings
	'[
		first line
			second line
	]
which is equivalent to:
	["first line", "\tsecond line"]

records:
	r = a: 1, b: 2, c: 3
	r :(Int, Int, c: Int) = 1, 2, c: 3
alternative syntax: # a: 1 b: 2 c: 3
to access an element:
	r.a
	r.0
records can be matched on smaller records:
	a, b = 1, 2, 3
tagged fields can be matched on untaged ones, if the name of variables match:
	a, b = a: 1, b: 2

mutating a record:
	r! = a: 1, b: 2, c: 3
	r.a = 10

record extension:
	(a: 1, b: 2)..(c: 3, d: 4)
or:
	(a: 1, b: 2). c: 3 d: 4
the above behaves like:
	(a: 1, b: 2, c: 3, d: 4)
masking fields:
	(a: 1, b: 2)..(b: 3, c: 4)
which behaves like:
	(a: 1, b: 3, c: 4)

function:
	f = { a :A , b :B | :C ... }
determining default values for parameters:
	f = { a = 1 | :B ... }
function call:
	f x y
which is equivalent to:
	f(x, y)

{ f x y } can be written as: \\ f x y

if'else:
	if condition {...} {...}
	if condition {...} \\ if c {...} \\ if c {...} {...}

and or:
	True & False
	True \ False
which are equivalent to:
	True .and {False}
	True .or {False}

matching:
	match a {
		b :B | ...
		:None | ...
	}

loops:
	loop { ... break ... }
	while {condition} { ... }
	for iterator { x | ... }
which is equivalent to:
	iterator.for'each { x | ... }

async function:
	af :Async(A) = { a :A || ... }
actor:
	a = Actor.new B.new(x, y)
	a.do { b :B || ... }

modules are files containing definitions
any definition whose name is the module's name, with the first letter capitalized,
	and possibly an additional extension (that starts with an apostrophe)
	will be exported (ie is accessable outside of the module)
to prevent an export, append an apostrophe at the end of its name: a' = ...
to access the definitions in a module which is inside a directory: dir.Definition
a package is a directory of modules which can be accessed like this (protocol can be gnunet, git or lib):
	p = package "protocol://address'of'package'directory"
definitions in "std" package are directly accessable
	this means that "std.Actor" and "Actor" are the same
packages that contain a file named "0.jina" (which must contain the main function) are program packages

structs:
	S := #
		a: A
		b:: B. 1 ; field with default value
defining methods:
	S = #
		new: { a :A |
			S. a
		}
		m1: { self, x :X | :Y
			...
		}
		m2: { self! |
			...
		}
private fields and methods (which can't be accessed from outside of the module),
	are indicated by puting an apostrophe at the end of their names
to create an instance of a struct:
	s :S = a: x b: y
	s = S. a: x b: y
	s = S.new a: x
calling a method:
	s.m x
which is equivalent to:
	S.m s x
note that to call a field that is a function, we have to use parentheses: (r.f)(x)

interfaces:
	I := #
		m1: Func (self, x: X) Y
		m2:: { self! |
			; default implementation
		}
interface inheritance:
	I3 := I1..I2..# ...
defining the methods of a struct that implements some interfaces:
	S = #
		...
	.. I1.
		...
	.. I2.
		...

generics:
	G := X | a: X b: B
interface bounded generics:
	G := X :I | a: X b: B

singletons:
	True := ()
	False := ()
	True = True.()
	False = False.()
unions:
	Bool := True + False
"?A" is a shortcut for "A+None", where "None" is a singleton:
	None := ()
	None = None.()
