single'line comment:
	; comment
multi'line comment:
	;
	multi'line
	comment
	;
or:
	;; multi'line
	comment
	;

variable definition:
	v = 1
private variables:
	v' = 1

symbols: 'a '123
UTF-8 string (an array of UTF-8 symbols): "abc"
string interpolation: "a {b}"

tuples: (1, 2, 3)
use matching to access the contained items
	x, y, z = 1, 2, 3
tuple can be matched on sub'tuples:
	x, y = 1, 2, 3
named tuples: (x: 1, y: 2, z: 3)
named tuples can be matched on tuples if the name of variables match:
	x, y = x: 1, y: 2
we can't have a tuple with only one element, but a named tuple with only one element is possible

arrays: [1, 2, 3]
empty array:
	x :[Int] = []
indexing: x_1
maps with symbols as keys:
	[a: 1, b: 2, c: 3]
maps with variables as keys:
	[a : 1, b : 2, c : 3]
empty map:
	x :[Char, Int] = []

function:
{ x, y -> ... }

actors:
a = Actor B(x)
a.do { b -> ... }

function call:
f x y
which is equivalent to:
f(x, y)

{f x y} can be written as: | f x y

if'else:
if condition {...} {...}
if condition {...} | if c {...} {...} | if c {...} {...}

and or:
'true & {'false}
'true \ {'false}

matching:
	match x {
		x :X -> ...
		x :'nil -> ...
	}
though in this simple case there is a shortcut: x?

loops:
	loop {...break...}
while {condition} { ... }
	for iterator { x -> ... }
which is equivalent to:
	iterator.for'each { x -> ... }

modules are made of classes, functions and constants
the file named "0" is the root module
the root module can contain the main function

c :Int = 1

f = { x :X, y :Y -> :Z
	...
}

import classes, functions and constants from other modules:
C', f' = import "module/path/relative/to/current/directory"
C', f: ff' = import "module/path/relative/to/current/directory"
C', f' = import "/module/path/relative/to/project/root"
C', f' = import "//package'name'majorVersionNumber/module/path"

class:
C = class [
	f1: F1,
	f2: F2,
	new: { f1 :F1 ->
		self.f2 = ...
	},
	m1: { a :A -> :R
		self.m2()
	},
	m2: { ->
		...
	}
]

calling a method:
	o.m a
mutating a field:
	o.f = ...

generic class:
C(t) { ... }

type alias:
	T := (T1, T2)
	T := T1(T2)
symbols and numbers are actually their own types:
	's :'s
	1 :1
enums:
	Bool := 'true + 'false
"C?" is a shortcut for "C + 'nil"

interfaces are classes without constructors:
	I = interface [f1: F1, f2: F2] {
		m1: { ... },
		m2: { ... }
	}
defining a class which implements interfaces I1 and I2:
	C :: I1 + I2 = class { ... }
