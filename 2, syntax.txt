single'line comment: //
multi'line comment: /* */

character: \a
UTF-8 string: "abc"
one word string: 'abc
string interpolation:
"a {b}"

tuples:
(1 2 3)
tuple can match on sub'tuples:
match (1 2 3) {x y -> ...}
named tuples:
(x: 1 y: 2 z: 3)
named tuples can be matched on tuples if the name of variables match:
match (x: 1 y: 2) {x y -> ...}
we can't have a tuple with only one element, but we can have a named tuple with only one element

arrays:
[1 2 3]
an empty array:
x :: Array<Int> = []
indexing: x_1
maps with string as keys:
[a: 1 b: 2 c: 3]
maps with variables as keys:
[{a}: 1 {b}: 2 {c}: 3]
an empty map:
x :: Map<Char, Int> = []

variable definition:
x = 1
assignment:
x .= 1
x.a = 1

closure:
{x y -> ...}
move closure:
^{x y -> ...}

actors:
a = Actor B(x)
a.do {b -> ...}

function call:
f(x y)
note that there must be no spaces between function name and the parentheses
"f x y" as the first expression of the line becomes "f(x y)"
"a b c, e f g" becomes "a b c e(f g)"

{f x y} can be written as: | f x y

if else:
if condition {...} {...}
if condition {} | if c {} {}

and or:
True && {False}
True || {False}

match x {
  Some(a) -> ...
  Nil -> ...
}

loops:
loop {...break...}
while {condition} {...}
for iterator {x -> ...}
which is equivalent to:
iterator.for'each {x -> ...}

in modules we can only have static definitions
ie we can only define types, functions, and constants which can be computed at compile'time
in a module, definitions marked with an apostrophe, are private
the file called "0.act" is the root module
the root module can contain the "main" function

c :: Int = 1

f :: &X &Y -> () = {x y ->
  ...
}

'M = import "module/path/relative/to/current/directory"
'a 'B 'c = import "module/path/relative/to/current/directory"
'x = import "module/path/relative/to/current/directory" .a
'Y = M.B
'M = import "/module/path/relative/to/project/root"
'M = import "//package'name'majorVersionNumber/module/path"

struct definition:
S :(
  a: A
  b: B
)
S :(A B)

generic struct:
S[a] :(a B)

type alias:
A := (B C)
A := B[C]

primitive type:
P :()
enum:
E := X | Y

implementing a type:
S :{
  m :: & &X -> Y = {self, x -> ...}
  n :: ! -> () = {self -> ...}
}

trait:
T :[
  m: & &A -> B
  n: ! -> ()
]
implementing a trait:
S :> T :{
  ...
}
