single'line comment: //
multi'line comment: /* */

character: \a
UTF-8 string: "abc"

tuples:
(1 2 3)
tuple can match on sub'tuples:
match (1 2 3) {x y -> ...}
named tuples:
(x: 1 y: 2 z: 3)
named tuples can be matched on tuples if the name of variables match:
match (x: 1 y: 2) {x y -> ...}
we can't have a tuple with only one element, but we can have a named tuple with only one element

arrays:
[1 2 3]
an empty array:
x :: Array<Int> = []
indexing: x_1
maps:
[\a => 1 \b => 2 \c => 3]
an empty map:
x :: Map<Char, Int> = []
maps with strings as keys:
["a" => 1 "b" => 2 "c" => 3]
[a: 1 b: 2 c: 3]

variable definition:
x = 1
assignment:
x .= 1
x.a = 1

closure:
{x y -> ...}
move closure:
^{x y -> ...}

actors:
a = Actor B(x)
a.do {b -> ...}

function call:
f x y
f1 a f2(x y)
f1 a (x y)
note that in nested function calls, inner ones must have parentheses,
  and there must be no spaces between function name and the parentheses

a b c, e f g
is equivalent to:
a b c e(f g)

{f x y} can be written as: | f x y

if else:
if condition {...} {...}
if condition {} | if c {} {}

and or:
True && {False}
True || {False}

match x {
  Some(a) -> ...
  Nil -> ...
}

loops:
loop {...break...}
while {condition} {...}
for iterator {x -> ...}
which is equivalent to:
iterator.for'each {x -> ...}

in modules we can only have static definitions
ie we can only define types, functions, and constants which can be computed at compile'time
in a module, definitions marked with an apostrophe, are private
the file called "0.cr" is the root module
the root module can contain the "main" function

c :: Int = 1

f :: &X &Y -> () = {x y ->
  ...
}

'M = import "module/path/relative/to/current/directory"
'a 'B 'c = import "module/path/relative/to/current/directory"
'x = import "module/path/relative/to/current/directory" .a
'x 'Y 'c = M .a .B .c
'M = import "/module/path/relative/to/project/root"
'M = import "//package'name'majorVersionNumber/module/path"

struct:
:: S a: A b: B
:: S A B
private struct:
:: 'S a: A b: B

enum:
:: E
:| X a: A b: B
:| Y

generic struct:
:: S[a] a B

type alias:
:: A = (B C)
:: A = B[C]

:: T {
  m :: & &X -> Y = {self, x -> ...}
  n :: ! -> () = {self -> ...}
}

trait:
:: t {
  m :: & &A -> B
  n :: ! -> ()
}
implementing a trait:
:: S t {
  ...
}
