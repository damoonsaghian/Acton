Jina is a programming language with sane memory management, actors, and a coherent syntax

Mahsa Jina Amini was a Kurdish girl whose tragic murder by the evil regime, started a revolution in Iran
at her funeral, these words were written on a stone above her grave:
	beloved Jina, you will not die, your name will become a code

memory management is done in a sane way, by distinguishing 5 kinds of variables:
, unique variables: definitions and function returns (by default):
	v :T = ...
	{ :T }
, immutable/mutable borrow variables: function parameters (by default):
	{ x :T, y !T | ... }
, immutable/mutable reference counted variables must be indicated explicitly:
	v ::T
	v !:T

assigning unique var to unique var:
	, stack type: copy
	, heap type: if not used in the code that follows, move, otherwise copy
assigning unique var to immutable/mutable borrow var is possible
assigning unique var to immutable/mutable reference counted var:
	, stack type: copy to heap
	, heap type: if not used in the code that follows, move, otherwise copy

immutable borrow var can only be assigned to immutable borrow var
mutable borrow var can only be assigned to immutable/mutable borrow var
borrow variable can't exit at the scope of the borrower, so they don't need memory management

assigning immutable ref counted var to unique var: not possible
assigning immutable ref counted var to immutable/mutable borrow var is/isn't possible
assigning immutable ref counted var to immutable ref counted var: increase reference count
assigning immutable ref counted var to mutable ref counted var: not possible

assigning mutable ref counted var to unique var: not possible
assigning mutable ref counted var to immutable/mutable borrow var: possible
assigning mutable ref counted var to immutable ref counted var: copy
assigning mutable ref counted var to mutable ref counted var: increase reference count

numbers are stored on the stack (thus don't need memory management)
lists and dictionaries are stored on the heap
small records will be kept on stack, big ones on the heap

"https://www.toptal.com/software/eliminating-garbage-collector"
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"

actors are used to achieve lock'free concurrency
sharing mutable data in concurrent parts of a program is problematic
a data race happens when these three behaviors occur:
, two or more pointers access the same data at the same time
, at least one of the pointers is being used to write to the data
, thereâ€™s no mechanism being used to synchronize access to the data

to deal with it, programming languages choose different approaches:
, abandon concurrency altogether; make single threaded programs
, implement complicated and error prone lock mechanisms
, abandon mutability like in pure functional programming; but since at the end, mutability is necessary,
	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used
	"https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples"
	"https://clojure-doc.org/articles/language/concurrency_and_parallelism/"
	any how, the lack of direct mutability, and the need for aggressive garbage collection,
		means that functional programming is not an efficient method
, use the approach taken by Pony "https://www.ponylang.io/"
	it controls aliasing (sharing) and mutability, using reference capabilities
	Pony's approach introduces many complexities, especially when dealing with generics
	i think the main reason for its complexities is that even class fields have reference capabilities

in Jina, as shown above, mutable variables will be copied, when captured in immutable functions
messages are sent to actors via immutable functions
so in Jina, all mutations will be synchronous

types show us what we can do with the data, ie which operations are valid
inheritance is problematic:
"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"
"https://www.tedinski.com/2018/06/26/variance.html"
i feel that this problem was the motivation behind dynamic typing (another bad design)
to avoid this problem, some languages (eg Rust) have two kinds of types:
, concrete types can be instantiated, but cannot have subtypes
, abstract types cannot be instantiated, but can have subtypes
Jina does the same, without actually spliting types into two kinds

Jina compiles to C, and can easily use existing C libraries
