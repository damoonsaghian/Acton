Jina is a "rustic" programming language with sane memory management, actors, and a coherent syntax,
	which compiles to Rust

Mahsa Jina Amini was a Kurdish girl whose tragic murder by the evil regime, started a revolution in Iran
at her funeral, these words were written on a stone above her grave:
	beloved Jina, you will not die, your name will become a code

Jina's syntax is elegant and coherent:
, types are treated like normal data
, classes and interfaces are just records
, constructing new objects, and implementing interfaces are just record extensions

memory management:
, in synchronous parts, it can be done at compile time
, in asynchronous parts, reference counting is used
"http://aardappel.github.io/lobster/memory_management.html"
"https://www.toptal.com/software/eliminating-garbage-collector"
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"

actors are used to achieve lock'free concurrency
sharing mutable data in concurrent parts of a program is problematic
a data race happens when these three behaviors occur:
, two or more pointers access the same data at the same time
, at least one of the pointers is being used to write to the data
, thereâ€™s no mechanism being used to synchronize access to the data

to deal with it, programming languages choose different approaches:
, abandon concurrency altogether; make single threaded programs
, implement complicated and error prone lock mechanisms
, abandon mutability like in pure functional programming; but since mutability is necessary any way,
	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used
	"https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples"
	"https://clojure-doc.org/articles/language/concurrency_and_parallelism/"
	any how, the lack of direct mutability, and the need for aggressive garbage collection,
		means that functional programming is not an efficient method
, use the approach taken by Pony "https://www.ponylang.io/"
	it controls aliasing (sharing) and mutability, using reference capabilities
	Pony's approach introduces many complexities, especially when dealing with generics
	i think the main reason for its complexities is that even class fields have reference capabilities

in Jina:
, numbers are small and have fixed size, so they will always be copied into variables
, strings, arrays, maps, records, functions and actors are immutable, and they are referenced by variables
	when captured in async functions, they will be reference counted
, there are three mutable types: boxes, mutable arrays, mutable maps; they are referenced by variables
	when captured in async functions, they will be copied
	so we can't mutate the environment of an async function; all mutations will be synchronous
