Jina is a programming language with sane memory management, actors, and a coherent syntax, that compiles to C

Mahsa Jina Amini was a Kurdish girl whose tragic murder by the evil regime, started a revolution in Iran
at her funeral, these words were written on a stone above her grave:
	beloved Jina, you will not die, your name will become a code

memory management:
, in synchronous parts: compile'time reference counting
	"http://aardappel.github.io/lobster/memory_management.html"
	"https://www.toptal.com/software/eliminating-garbage-collector"
	"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"
, in asynchronous parts: runtime reference counting is used

any heap reference keeps the address of the actor, that it originates from
only this original actor can destroy the reference
other actros just send messages
so we do not need atomic reference counting

numbers will always be copied into variables; they don't need compile'time/run'time ref counting
in the case of arrays, a small part at the start is stored on the stack
	this part will be referenced by variables in sync parts, and copied when captured in async functions
	so arrays don't need heap allocation (and compile'time/run'time ref counting), if they are small

self'referential fields of structures are necessarily private, and use weak references

actors are used to achieve lock'free concurrency
sharing mutable data in concurrent parts of a program is problematic
a data race happens when these three behaviors occur:
, two or more pointers access the same data at the same time
, at least one of the pointers is being used to write to the data
, thereâ€™s no mechanism being used to synchronize access to the data

to deal with it, programming languages choose different approaches:
, abandon concurrency altogether; make single threaded programs
, implement complicated and error prone lock mechanisms
, abandon mutability like in pure functional programming; but since mutability is necessary any way,
	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used
	"https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples"
	"https://clojure-doc.org/articles/language/concurrency_and_parallelism/"
	any how, the lack of direct mutability, and the need for aggressive garbage collection,
		means that functional programming is not an efficient method
, use the approach taken by Pony "https://www.ponylang.io/"
	it controls aliasing (sharing) and mutability, using reference capabilities
	Pony's approach introduces many complexities, especially when dealing with generics
	i think the main reason for its complexities is that even class fields have reference capabilities

in Jina, mutable variables will be copied, when captured in async functions
so we can't mutate the environment of an async function; all mutations will be synchronous

types show us what we can do with the data, ie which operations are valid
inheritance is problematic:
"https://stackoverflow.com/questions/7266596/why-avoid-subtyping"
"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"
"https://www.tedinski.com/2018/02/13/inheritance-modularity.html"
"https://www.tedinski.com/2018/06/26/variance.html"
i feel that this problem was the motivation behind dynamic typing (another bad design)
to avoid this problem, some languages (eg Rust) use use two kind of types:
, concrete types can be instantiated, but cannot have subtypes
, abstract types cannot be instantiated, but can have subtypes
Jina acheives the same, without splitting the types into two kinds
in Jina, the only difference between types and normal values, is that, types are not their own subtypes
as you will see, all the complexities of type systems, including the one mentioned above,
	will be naturally resolved in Jina
