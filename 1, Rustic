Rustic is a programming language, based on actors and ownership mechanism

we can use mutable borrow (!T) and immutable borrow (&T) to access data synchronously
for asynchronous access we use actors
"https://riker.rs/hierarchy/"
"https://crates.io/crates/aurum_actors"
  "https://docs.rs/aurum_actors/0.0.1/aurum_actors/#forgeable-references"
  "https://docs.rs/aurum_actors/0.0.1/aurum_actors/core/index.html#sending-messages"
"https://github.com/elfo-rs/elfo"
  "https://docs.rs/elfo/0.1.19/elfo/struct.Addr.html"
  "https://github.com/elfo-rs/elfo/blob/master/elfo/examples/usage.rs"
"https://docs.rs/acto/0.1.0/acto/struct.ActorId.html"
  "https://github.com/Actyx/acto/blob/master/examples/pingpong.rs"
"https://github.com/Xudong-Huang/may_actor"
actor variables actually hold an ID, and thus can easily be copied across async parts of the program
this implies that an ID can refer to a deallocated actor
when we send a message to a deallocated actor, it just does nothing

Rustic compiles to Rust line by line
so Rust's error messages remain useful, and making a converter in the future will be easy
"https://arzg.github.io/lang/"
"https://github.com/alilleybrinker/langs-in-rust"
"https://github.com/koto-lang/koto"
"https://github.com/PistonDevelopers/dyon"
"https://github.com/jfecher/ante"

Rust makes bad programming hard, and good programming fun
Rust does not hide inherent complexity, in fact it bolds it, so we can see it, and avoid it
by inherent complexity i mean a complexity which can not be abstracted away completely
  ie if we try to hide it, it will re'emerge somewhere else
in fact, hiding inherent complexity usually leads to choosing the wrong approach
"https://fasterthanli.me/articles/a-half-hour-to-learn-rust"

maybe the most prominent example of an inherent complexity in programming is memory management
rather than hiding it behind a garbage collector, Rust uses ownership mechanism
  which allows Rust to eliminate the need for a garbage collector in synchronous programming
"https://www.toptal.com/software/eliminating-garbage-collector"
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"
to also eliminate garbage collection in asynchronous parts, we use actors

sharing mutable data in concurrent parts of a program is problematic
a data race happens when these three behaviors occur:
, two or more pointers access the same data at the same time
, at least one of the pointers is being used to write to the data
, thereâ€™s no mechanism being used to synchronize access to the data

to deal with it, programming languages choose different approaches:
, abandon concurrency altogether; make single threaded programs
, implement complicated and error prone lock mechanisms
, abandon mutability like in pure functional programming; but since mutability is necessary any way,
  a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used
  "https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples"
  "http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types"
  any how, lack of direct mutability, and the need for aggressive garbage collection,
  means that functional programming is not an efficient method
, use the approach taken by Pony "https://www.ponylang.io/"
  it doesn't abandon aliasing (sharing) nor mutability, instead it controls them using reference capabilities
  Pony's approach introduces many complexities, especially when dealing with generics
  i think the main reason for its complexities is that even class fields have reference capabilities

the right approach is to use ownership mechanism (as is done in Rust):
, any resource has an owner
, borrows must have a lifetime less than the owner
, mutable borrow has exclusive access to the resource, during its lifetime

static data (functions, structs, constants): no problem, copy or share by reference
dynamic data:
, if data is small we usually put it on stack; so we don't share it across the program, we copy it
, if data is big we put it on the heap and make references to it
  if data is immutable we just have to manage its lifetime,
    either statically (using "&"), or dynamically (using "Arc")
  but if data is mutable we have to check if the read_write_lock pattern is fulfilled, using "&mut" or "Actor"
  "Mutex" or "RwLock" check read_write_lock pattern at runtime, and make the program to panic, if it's failed

owner can:
, access and mutate the resource
, lend the resource to a reference
, hand over the ownership (move), or deallocate resource
but during a lend, owner can't:
, mutate the resource
, mutably lend resource to another reference
, hand over the ownership (move), or deallocate resource
and during a mutable lend, owner can't even access the resource

immutable (and thus sharable) references can:
, access borrowed resource
, immutably lend resource to other references
mutable (and thus exclusive) reference can:
, access and mutate the resource
, mutably lend resource to another reference
, immutably lend resource, but during this lending, they can't mutate it
  just like when an owner immutably lends its resource

during shared borrow (immutable borrow) no one owns the data
  so even the original owner can't change it
during mutable borrow the (unique) borrower owns it
so mutable borrow is actually a temporary transfer of ownership

types show us what we can do with the data, ie which operations are valid
the class hierarchy design, like the one in Java, is problematic
  "http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html"
also the problem of covariance for generic types, has its root in this problem
  "https://en.wikipedia.org/wiki/Wildcard_(Java)"
i think this problem is also the motivation for dynamic typing (another bad design)
the right way:
, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes
, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes

some of the subtleties of Rust's syntax:

s: String -> &s: &String -> &s[..]: &str
v: Vec<T> -> &v: &Vec<T> -> &v[..]: &[T]
&str and &[T] are slices; str and [T] are unsized types
slicing is like borrowing from an unsized type
since the slice contains the size, the lending type itself doesn't need to have a definite size

x = a[i] -> this is possible if the elements of "a" are copy (cause moving out of collections is not possible)
x = &a[i] -> this is for the case when the elements are not copy
x = a[i..j] -> this is always invalid
x = &a[i..j] -> slicing

auto ref/deref for self in method calls:
  compiler inserts as many * or & as necessary to get it right

deref coercion:
, &T -> &U when T: Deref<Target=U>
, &mut T -> &U when T: Deref<Target=U>
, &mut T -> &mut U when T: DerefMut<Target=U>
examples:
  &&i32 -> &i32 because &i32: Deref<Target=i32>
  &String -> &str because String: Deref<Target=str>
  &Vec<T> -> &[T] because Vec<T>: Deref<Target=[T]>
  &Arc<T> -> &T because Arc<T>: Deref<Target=T>
"https://github.com/rust-lang/rfcs/blob/master/text/0241-deref-conversions.md"

arrays like tuples have fixed size and thus stored on stack
but since they are homogeneous (all elements are of the same type), they can be indexed at runtime
vectors and hash tables are homogeneous, varying sized collections

a closure is like an anonymous struct made of variables captured from environment,
  that is callable (implements Fn/FnMut/FnOnce trait)
so all closures are unique types, but they have traits in common
note that if we put a generic type parameter in the return type of a function,
  we have to provide the concrete type when we call the function
  thus we can't use generic type parameters to return a closure, we have to use "impl"

"fn(T1) -> T2" is not an unsized type like "str", it's a function pointer

"x.m()" is method call syntax, which completely differs from "(x.m)()"

Rust libgccjit

"https://crates.io/crates/serde"
"https://github.com/ron-rs/ron"

math:
https://nalgebra.org/rustdoc/nalgebra/index.html
https://gitlab.com/ornamentist/un-algebra
https://github.com/rustsim/alga
https://www.sympy.org/en/index.html
