
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Jina</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Jina'><h1>Jina</h1></a>
<h2>1, Jina</h2><div>Jina is a programming language with sane memory management, actors, and a coherent syntax</div><div><p></p></div><div>Mahsa Jina Amini was a 22 years old girl, murdered by the evil regime in Iran</div><div>at her funeral, these words were written on a stone above her grave:</div><div>	beloved Jina, you will not die, your name will become a code</div><div><p></p></div><div>memory management is done in a sane way, by distinguishing 2 kinds of variables:</div><div>, immutable/mutable borrow variables</div><div>, immutable/mutable own variables:</div><div>note that in Jina, mutability and ownership are properties of variables, not types</div><div><p></p></div><div>immutable borrow var can only be put into immutable borrow var</div><div>mutable borrow var can only be put into immutable/mutable borrow var</div><div>note that here "put into" means:</div><div>, variable assignment</div><div>, field assignment</div><div>, variable capture in functions</div><div><p></p></div><div>putting immutable own var into immutable/mutable borrow var is/isn't possible</div><div>putting mutable own var into immutable/mutable borrow var is possible</div><div>putting immutable/mutable own var into immutable/mutable own var:</div><div>, stack part: copy</div><div>, heap part: if reference count is zero and it isn't used in the following code, move,</div><div>	otherwise increase reference count</div><div>putting immutable/mutable own var into mutable/immutable own var is not possible</div><div><p></p></div><div>numbers are stored on the stack (thus don't need memory management)</div><div>lists and dictionaries are stored on the heap</div><div>small records will be kept on stack, big ones on the heap</div><div><p></p></div><div><a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div><a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div><p></p></div><div>actors are used to achieve lock'free concurrency</div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, thereâ€™s no mechanism being used to synchronize access to the data</div><div><p></p></div><div>to deal with it, programming languages choose different approaches:</div><div>, abandon concurrency altogether; make single threaded programs</div><div>, implement complicated and error prone lock mechanisms</div><div>, abandon mutability like in pure functional programming; but since at the end, mutability is necessary,</div><div>	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used</div><div>	<a href='https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples'>https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples</a></div><div>	<a href='https://clojure-doc.org/articles/language/concurrency_and_parallelism/'>https://clojure-doc.org/articles/language/concurrency_and_parallelism/</a></div><div>	any how, the lack of direct mutability, and the need for aggressive garbage collection,</div><div>		means that functional programming is not an efficient method</div><div>, use the approach taken by Pony <a href='https://www.ponylang.io/'>https://www.ponylang.io/</a></div><div>	it controls aliasing (sharing) and mutability, using reference capabilities</div><div>	Pony's approach introduces many complexities, especially when dealing with generics</div><div>	i think the main reason for its complexities is that even class fields have reference capabilities</div><div><p></p></div><div>in Jina, as shown above, mutable variables can't be captured in immutable own functions</div><div>messages are sent to actors via immutable own functions</div><div>so in Jina, all mutations will be synchronous</div><div><p></p></div><div>immutable functions with null return can be called asynchronously, since they can't affect their environment</div><div><p></p></div><div>types show us what we can do with the data, ie which operations are valid</div><div>inheritance is problematic:</div><div><a href='https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)'>https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></div><div><a href='https://www.tedinski.com/2018/06/26/variance.html'>https://www.tedinski.com/2018/06/26/variance.html</a></div><div>i feel that this problem was the motivation behind dynamic typing (another bad design)</div><div>to avoid this problem, some languages (eg Rust) have two kinds of types:</div><div>, concrete types can be instantiated, but cannot have subtypes</div><div>, abstract types cannot be instantiated, but can have subtypes</div><div>Jina does the same, without actually spliting types into two kinds</div><div><p></p></div><div>Jina compiles to C, and can easily use existing C libraries</div>
<h2>2, syntax</h2><div>comment line:</div><div>	;; comment</div><div>comment block:</div><div>	;(</div><div>	pairs of parentheses can be nested: ()</div><div>	parentheses inside quotes will be ignored: ")"</div><div>	)</div><div><p></p></div><div>immutable borrow variable definition:</div><div>	v :T = ...</div><div>	v = ...</div><div>mutable borrow variable:</div><div>	v !T = ...</div><div>	v! = ...</div><div>immutable own variable:</div><div>	v ::T = ...</div><div>	v :: = ...</div><div>mutable own variable:</div><div>	v !:T = ...</div><div>	v !: = ...</div><div>assignment after definition (only possible for mutable variables):</div><div>	v = ...</div><div><p></p></div><div>numeric types:</div><div>, Num: floating point with mid-rad interval arithmetics</div><div>, Num'z: multi'precision integer</div><div>, Num'u: compiled to "unsigned int" type in C</div><div>, Num'c: compiled to "char" type in C</div><div>literal numbers:</div><div>	1'234'567'890 ;; Num (by default), can be Num'z, or Num'u too</div><div>	1.23e4 ;; Num</div><div>	123z ;; Num'z</div><div>	0x1234'5678'9abc'def0 ;; Num'u (on 32 bit systems this number is too big, and will produce an error)</div><div>	0'ab ;; Num'c (the character with hexadecimal ASCII code 0xab)</div><div>	0x ;; Num'c (ASCII code for "a" character)</div><div><p></p></div><div>lists:</div><div>	l :List(Num) = [1, 2, 3]</div><div>indexing:</div><div>	l_1</div><div>negative indices count from the end of the list</div><div>mutating lists:</div><div>	l! = [1, 2, 3]</div><div>	l..put 0 index: 0 ;; [0, 2, 3]</div><div>	l..put 4 index: 3 ;; [0, 2, 3, 4]</div><div>initial value of lists will be kept on stack</div><div>heap allocation will be used only when the lists needs to grow beyond its initial size</div><div><p></p></div><div>strings are UTF8 encoded, and implemented using lists:</div><div>	s :String = "abc def"</div><div>one word string:</div><div>	'abc</div><div>string interpolation: "abc{x}"</div><div>it's better to split long strings into a list of single'line strings:</div><div>	""</div><div>	first line</div><div>		second line</div><div>	""</div><div>which is equivalent to:</div><div>	["first line", "\tsecond line"]</div><div><p></p></div><div>dictionaries are indexed using strings (instead of integers as in lists):</div><div>	d :Dict(Num) = ["a": 1, "b": 2, "c": 3]</div><div>when keys are one word strings, this can also be written as:</div><div>	[a: 1, b: 2, c: 3]</div><div>indexing:</div><div>	d_'a</div><div><p></p></div><div>records:</div><div>	r :(a: Num, b: Num, c: Num) = a: 1, b: 2, c: 3</div><div>	r :(Num, Num, c: Num) = 1, 2, c: 3</div><div>alternative syntax:</div><div>	. a: 1 b: 2 c: 3</div><div>to access an element:</div><div>	r.a</div><div>	r.0</div><div>records can be matched on smaller records:</div><div>	a, b = 1, 2, 3</div><div>tagged fields can be matched on untaged ones, if the name of variables match:</div><div>	a, b = a: 1, b: 2</div><div>mutating a record:</div><div>	r.a = 10</div><div><p></p></div><div>record extension:</div><div>	(a: 1, b: 2) & (c: 3, d: 4)</div><div>the above behaves like:</div><div>	(a: 1, b: 2, c: 3, d: 4)</div><div>masking fields with the same type:</div><div>	(a: 1, b: 2) & (b: 3, c: 4)</div><div>which behaves like:</div><div>	(a: 1, b: 3, c: 4)</div><div><p></p></div><div>function:</div><div>	f = { a :A , b !B | :C ... }</div><div>note that the type of above function is:</div><div>	f :{ a :A , b !B | C }</div><div>this somehow strange type is to avoid contravarient behaviour of function arguments, when we introduce interfaces</div><div>function call:</div><div>	f x y</div><div>which is equivalent to these forms:</div><div>	f(x, y)</div><div>	(x, y) # f</div><div>	f b: y a: x</div><div><p></p></div><div>default values for parameters:</div><div>	f = { a :A = ... , b !B = ... | :C ... }</div><div>	f b: y</div><div>	f x</div><div>	f()</div><div><p></p></div><div>{ f x y } can be written as: || f x y</div><div><p></p></div><div>conditional expression:</div><div>	condition..then { } else: { }</div><div>	condition..then { } { }</div><div>	condition..then { } || c.then { } || c.then { } { }</div><div><p></p></div><div>and or:</div><div>	a && b</div><div>	a \\ b</div><div>which are equivalent to:</div><div>	a..and {b}</div><div>	a..or {b}</div><div>not: -a</div><div><p></p></div><div>matching:</div><div>	a # {</div><div>		b :B | ...</div><div>		() | ...</div><div>	}</div><div><p></p></div><div>actor:</div><div>	a = Actor.new B.new(x, y)</div><div>	a..do { b !B | ... }</div><div><p></p></div><div>iterators:</div><div>	iter..each { x | ... }</div><div><p></p></div><div>modules are files containing definitions</div><div>any definition whose name is the module's name, with the first letter capitalized,</div><div>	and possibly an additional extension (separated with an apostrophe),</div><div>	will be exported (ie is accessable outside of the module)</div><div>to hide the internals of a definition, append an apostrophe at the end of its name: a' = ...</div><div>to access the definitions in a module which is inside a directory: dir.Definition</div><div>to hide a module so it can't be accessed from modules in the parent directory,</div><div>	append an apostrophe at the end of its file name</div><div><p></p></div><div>a package is a collection of modules that are compiled to a shared object file,</div><div>	which can be dynamically linked to</div><div>to use a package in a project, create a ".p" file</div><div>".p" files contain:</div><div>, URL lines (protocol can be gnunet, git or lib):</div><div>	protocol://address'of'package'directory</div><div>, comment lines, begining with a semicolon</div><div>URL lines will be tried in the given order, until one is available</div><div>if the protocol is git or gnunet, the following line must contain a public key,</div><div>	will be used to check the given signature</div><div>to use a module inside a package:</div><div>	package'file'name.Definition</div><div>definitions in "std" package are directly accessable; there is no need for a ".p" file</div><div>packages that contain a file named "0.jina" (which must contain the init function) are program packages</div><div><p></p></div><div>structs:</div><div>	S := .</div><div>		a: A</div><div>		b:: B. 1 ; field with default value</div><div>defining methods:</div><div>	S = .</div><div>		new: { a :A |</div><div>			S. a</div><div>		}</div><div>		m1: { self, x :X | :Y</div><div>			...</div><div>		}</div><div>		m2: { self! |</div><div>			...</div><div>		}</div><div>private fields and methods (which can't be accessed from outside of the module),</div><div>	are indicated by puting an apostrophe at the end of their names</div><div>to create an instance of a struct:</div><div>	s :S = a: x, b: y</div><div>	s = S. a: x b: y</div><div>	s = S. a: x ; fields with default values can be omited</div><div>	s = S.new a: x</div><div>calling a method:</div><div>	s..m x</div><div>which is equivalent to:</div><div>	S.m s x</div><div><p></p></div><div>generics:</div><div>	S := a: X', b: X'</div><div>bounded generics:</div><div>	S := a: X':I, b: X'</div><div><p></p></div><div>singletons:</div><div>	Bool'true' := ()</div><div>	Bool'true = Bool'true. ()</div><div>	Bool'false' := ()</div><div>	Bool'false = Bool'false. ()</div><div>unions:</div><div>	Bool := Bool'true \ Bool'false</div><div>type "?A" is a shortcut for "A\()"</div><div><p></p></div><div>interfaces:</div><div>	I := .</div><div>		m1: { self :A', x :X | Y }</div><div>		m2:: { self !A' |</div><div>			; default implementation</div><div>		}</div><div>interface inheritance:</div><div>	I3 := I1&I2& . ...</div><div>defining the methods of a struct that implements some interfaces:</div><div>	S = .</div><div>		...</div><div>	& I1.</div><div>		...</div><div>	& I2.</div><div>		...</div><div><p></p></div><div>to directly enter C code:</div><div>	;{...}</div><div>beware! with great power comes great resposibility</div></body></html>