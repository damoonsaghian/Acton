
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Jina</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Jina'><h1>Jina</h1></a>
<h2>1, Jina</h2><div>Jina is a simple coherent programming language</div><div>Mahsa Jina Amini was a girl whose tragic murder by the evil regime, started a revolution in Iran</div><div>on Jina's grave there is a simple message:</div><div>	beloved Jina, you will not die, your name will become a code</div><div><p></p></div><div>it uses some simple concepts to simplify the complexities of programming languages:</div><div>, symbols and records are used to define class hierarchy</div><div>, actors are used to achieve lock'free concurrency, as well as static memory managment</div><div><p></p></div><div>memory management:</div><div>, in synchronous parts, it can be done statically (no need for a garbage collector)</div><div>	<a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div>	<a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div>, in asynchronous parts, use actors</div><div>	actor variables actually hold an ID, and thus can easily be copied across async parts of the program</div><div>	this implies that an ID can refer to a deallocated actor</div><div>	when we send a message to a deallocated actor, it will be ignored</div><div><a href='https://riker.rs/hierarchy/'>https://riker.rs/hierarchy/</a></div><div><a href='https://crates.io/crates/aurum_actors'>https://crates.io/crates/aurum_actors</a></div><div>	<a href='https://docs.rs/aurum_actors/latest/aurum_actors/#forgeable-references'>https://docs.rs/aurum_actors/latest/aurum_actors/#forgeable-references</a></div><div><a href='https://github.com/Xudong-Huang/may_actor'>https://github.com/Xudong-Huang/may_actor</a></div><div><p></p></div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, thereâ€™s no mechanism being used to synchronize access to the data</div><div><p></p></div><div>to deal with it, programming languages choose different approaches:</div><div>, abandon concurrency altogether; make single threaded programs</div><div>, implement complicated and error prone lock mechanisms</div><div>, abandon mutability like in pure functional programming; but since mutability is necessary any way,</div><div>	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used</div><div>	<a href='https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples'>https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples</a></div><div>	<a href='http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types'>http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types</a></div><div>	any how, the lack of direct mutability, and the need for aggressive garbage collection,</div><div>		means that functional programming is not an efficient method</div><div>, use the approach taken by Pony <a href='https://www.ponylang.io/'>https://www.ponylang.io/</a></div><div>	it doesn't abandon aliasing (sharing) nor mutability, instead it controls them using reference capabilities</div><div>	Pony's approach introduces many complexities, especially when dealing with generics</div><div>	i think the main reason for its complexities is that even class fields have reference capabilities</div><div>, simply use actors, and only allow actors and copy types to be shared concurrently</div><div><p></p></div><div>types show us what we can do with the data, ie which operations are valid</div><div><a href='https://en.wikipedia.org/wiki/Algebraic_data_type'>https://en.wikipedia.org/wiki/Algebraic_data_type</a></div><div>in Jina we have:</div><div>, numeric types: Int, Float</div><div>, symbols which are their own types</div><div>, maps and arrays</div><div>, function types</div><div>, sum types (enums)</div><div>, records and tuples</div><div>, structs which are records taged with symbols</div><div><p></p></div><div>the class hierarchy design, like the one in Java, is problematic</div><div>	<a href='http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html'>http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html</a></div><div>also it leads to the problem of covariance for generic types</div><div>	<a href='https://en.wikipedia.org/wiki/Wildcard_(Java)'>https://en.wikipedia.org/wiki/Wildcard_(Java)</a></div><div>i feel that this problem was the motivation for dynamic typing (another bad design)</div><div>one solution is to have two kind of types:</div><div>, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes</div><div>, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes</div><div>but i think it's enough to just avoid direct subtype replacement, and instead use restricted generics</div><div><p></p></div><div>Jina compiles to C:</div><div><a href='https://yosefk.com/blog/c-as-an-intermediate-language.html'>https://yosefk.com/blog/c-as-an-intermediate-language.html</a></div><div><a href='https://wiki.c2.com/?CeeAsAnIntermediateLanguage'>https://wiki.c2.com/?CeeAsAnIntermediateLanguage</a></div><div><a href='https://github.com/dbohdan/compilers-targeting-c'>https://github.com/dbohdan/compilers-targeting-c</a></div>
<h2>2, syntax</h2><div>comment line:</div><div>	; comment</div><div>note that ";" must be the first non'whitespace charactor on the line</div><div>comment block:</div><div>	;[ multi'line</div><div>	comment</div><div>	]</div><div><p></p></div><div>variable definition:</div><div>	v = ...</div><div>type anotation:</div><div>	v :T = ...</div><div><p></p></div><div>symbols:</div><div>	'symbol</div><div>symbols are actually their own types:</div><div>	's :'s</div><div>a string is an array of UTF-8 symbols, and can be written as:</div><div>	'[abc]</div><div>string interpolation: '[abc{x}]</div><div><p></p></div><div>arrays:</div><div>	[1, 2, 3]</div><div>empty array:</div><div>	x :[Int] = []</div><div>indexing:</div><div>	x_1</div><div>maps with symbols as keys:</div><div>	[a: 1, b: 2, c: 3]</div><div>maps with variables as keys:</div><div>	[a : 1, b : 2, c : 3]</div><div>empty map:</div><div>	x :[Char, Int] = []</div><div><p></p></div><div>tuple:</div><div>	t = (1, 2, 3)</div><div>to access an element:</div><div>	t.1</div><div>tuples can be matched on sub'tuples:</div><div>	a, b = 1, 2, 3</div><div>to change an element:</div><div>	t.1 = 2</div><div>records (named tuples):</div><div>	nt = (a: 1, b: 2, c: 3)</div><div>to access an element:</div><div>	nt.a</div><div>records can be matched on tuples if the name of variables match:</div><div>	a, b = a: 1, b: 2</div><div>record/tuple product:</div><div>	p = (a: 1, b: 2) * (c: 3)</div><div>	p == (a: 1, b: 2, c: 3)</div><div><p></p></div><div>structs are like taged tuples or taged record:</div><div>	s1 = 's(1, 2)</div><div>	s1 = 's 1 2</div><div>	s2 = 's(a: 1, b: 2)</div><div>	s2 = 's a: 1 b: 2</div><div>note the types:</div><div>	s1 :'s(Int, Int)</div><div>	s2 :'s(a: Int, b: Int)</div><div>accessing elements is like in tuples and records:</div><div>	s1.1</div><div>	s2.a</div><div><p></p></div><div>function:</div><div>	f = { a :A, b :B -&gt; ... }</div><div>function call:</div><div>	f x y</div><div>which is equivalent to:</div><div>	f(x, y)</div><div><p></p></div><div>{f x y} can be written as: | f x y</div><div><p></p></div><div>if'else:</div><div>	if condition {...} {...}</div><div>	if condition {...} | if c {...} {...} | if c {...} {...}</div><div>and or:</div><div>	'true .and {'false}</div><div>	'true .or {'false}</div><div>matching:</div><div>	match a {</div><div>		's b -&gt; ...</div><div>		'nil -&gt; ...</div><div>	}</div><div><p></p></div><div>loops:</div><div>	loop {...break...}</div><div>while {condition} { ... }</div><div>	for iterator { x -&gt; ... }</div><div>which is equivalent to:</div><div>	iterator.for'each { x -&gt; ... }</div><div><p></p></div><div>actors:</div><div>a = Actor B(x)</div><div>a.do { b -&gt; ... }</div><div><p></p></div><div>modules are files containing definitions</div><div>to make a definition private, append an apostrophe to the end of its name</div><div>the file named "0" is the root module</div><div>the root module can contain the main function</div><div>to import definitions from other modules:</div><div>	m' = import '[module/path/relative/to/current/directory]</div><div>	C', f' = m</div><div>	x' = m.y</div><div>	m' = import '[/module/path/relative/to/project/root]</div><div>	m' = import '[//hostname/package name including major version/module/path]</div><div><p></p></div><div>type alias:</div><div>	T := (T1, T2)</div><div>enums:</div><div>	Bool := 'true + 'false</div><div>"C?" is a shortcut for "C + 'nil"</div><div>type aliases are applied only when comparing types</div><div><p></p></div><div>classes are autually type aliases for structs:</div><div>	C := 's(a: A, b: B)</div><div>defining methods:</div><div>	C = (</div><div>		new: { a :A -&gt; :C</div><div>			b = ...</div><div>			's(a: a, b: b)</div><div>		},</div><div>		m: { self :C, x :X -&gt;</div><div>			...</div><div>		}</div><div>	)</div><div>creating an instance:</div><div>	i = C.new x</div><div>or:</div><div>	i :C = 's a: x b: y</div><div>note that in the second case, declaring the type is mandatory</div><div>calling a method:</div><div>	i .m x</div><div>which is equivalent to:</div><div>	C.m i x</div><div><p></p></div><div>derived class (inheritance):</div><div>D := C * (e: E)</div><div>D :&gt; C</div><div><p></p></div><div>generics:</div><div>	C(t) := 's(a: t, b: B)</div><div>restricted generics:</div><div>	C(t :&gt; D) := 's(a: t, b: B)</div>
<h2>3, graphics</h2><div>software rendering gives us a lot more flexibility,	because we won't be limited by a hardware implementation,</div><div>	with triangle only rasterization, isolated shader programs, and fixed size buffers</div><div>GPU equivalent performance can be achieved using SIMD (<a href='https://en.wikipedia.org/wiki/SIMD'>https://en.wikipedia.org/wiki/SIMD</a>)</div><div><a href='https://www.quora.com/What-is-the-main-difference-between-SIMD-and-GPU'>https://www.quora.com/What-is-the-main-difference-between-SIMD-and-GPU</a></div><div><a href='https://stackoverflow.com/questions/27333815/cpu-simd-vs-gpu-simd'>https://stackoverflow.com/questions/27333815/cpu-simd-vs-gpu-simd</a></div><div><a href='https://en.wikipedia.org/wiki/Vector_processor'>https://en.wikipedia.org/wiki/Vector_processor</a></div><div><a href='https://en.wikipedia.org/wiki/RISC-V#Vector_set'>https://en.wikipedia.org/wiki/RISC-V#Vector_set</a></div><div><p></p></div><div>graphical objects are made of primitives; each primitive has a specific algorithm for rasterization</div><div>2d primitives: point, line, curve, triangle, curved area</div><div>3d objects made of flat surfaces will be broken up into triangles</div><div>3d objects made of curved surfaces can be broken up into a number of primitive 3d surfaces,</div><div>	which can be easily projected to 2d</div><div><a href='https://en.wikipedia.org/wiki/Quadric'>https://en.wikipedia.org/wiki/Quadric</a></div><div>also interpolation is a good method for amorphous surfaces</div><div><p></p></div><div>2d objects will be rasterized into pixels (a pixel is a coordinate plus a color value)</div><div>then these rasterized objects will be drawn in the framebuffer,</div><div>	in layers over each other (in an overlay on top of all 3d objects)</div><div>rasterizing 3d objects, produces an array of fragments</div><div>	a fragment, besides color, contains a normal and a depth</div><div>when creating the pixels of the framebuffer from the fragments,</div><div>	the normals are used for lighting, and the depths are used for z'buffer</div><div><p></p></div><div>graphical objects are of 2 kinds:</div><div>, those which we know will remain unchanged the next time we want to draw to the framebuffer</div><div>	these objects are first rasterized into memory, then we copy it into framebuffer</div><div>, those which we know will be changed (scaled, rotated, moved in z direction),</div><div>	the next time we want to draw to the framebuffer (which happens a lot for animations with high frame rate)</div><div>	these objects will be drawn directly to the framebuffer</div><div>(framebuffer uses double buffering and v'sync)</div><div>note that if an object just moves in x'y plane (without rotation), the cached rasterization is still useful</div><div>	for 2d objects we simply add a constant to the position of all pixels</div><div>	for 3d objects we may additionally want to recompute the lighting of pixels from fragments</div><div><p></p></div><div>data structure for graphical objects:</div><div>, primitives</div><div>, material</div><div>, cached rasterization (can be none)</div><div><p></p></div><div>with a scene graph we can have fine grained graphical objects which can be combined easily</div><div><p></p></div><div><a href='https://en.wikipedia.org/wiki/Midpoint_circle_algorithm'>https://en.wikipedia.org/wiki/Midpoint_circle_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm'>https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</a></div><div><a href='http://members.chello.at/~easyfilter/bresenham.html'>http://members.chello.at/~easyfilter/bresenham.html</a></div><div><a href='https://nothings.org/gamedev/rasterize/'>https://nothings.org/gamedev/rasterize/</a></div><div><a href='https://magcius.github.io/xplain/article/'>https://magcius.github.io/xplain/article/</a></div><div><a href='https://en.wikipedia.org/wiki/Stencil_buffer'>https://en.wikipedia.org/wiki/Stencil_buffer</a></div><div><a href='https://www.scratchapixel.com'>https://www.scratchapixel.com</a></div><div><a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF'>https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF</a></div></body></html>