
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Jina</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Jina'><h1>Jina</h1></a>
<h2>1, Jina</h2><div>Jina is a simple coherent programming language</div><div>Mahsa Jina Amini was a girl whose tragic murder by the evil regime, started a revolution in Iran</div><div>at her funeral, these words were written on a stone above her grave:</div><div>	beloved Jina, you will not die, your name will become a code</div><div><p></p></div><div>all complexities of usual type systems are resolved in a natural way,</div><div>	using records, record extensions, and treating types as normal data</div><div><p></p></div><div>actors are used to achieve lock'free concurrency, as well as static memory managment</div><div><p></p></div><div>memory management:</div><div>, in synchronous parts, it can be done statically (no need for a garbage collector)</div><div>	<a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div>	<a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div>, in asynchronous parts, use actors</div><div>	actor variables actually hold an ID, and thus can easily be copied across async parts of the program</div><div>	this implies that an ID can refer to a deallocated actor</div><div>	when we send a message to a deallocated actor, it will be ignored</div><div><a href='https://riker.rs/hierarchy/'>https://riker.rs/hierarchy/</a></div><div><a href='https://crates.io/crates/aurum_actors'>https://crates.io/crates/aurum_actors</a></div><div>	<a href='https://docs.rs/aurum_actors/latest/aurum_actors/#forgeable-references'>https://docs.rs/aurum_actors/latest/aurum_actors/#forgeable-references</a></div><div><a href='https://github.com/Xudong-Huang/may_actor'>https://github.com/Xudong-Huang/may_actor</a></div><div><p></p></div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, thereâ€™s no mechanism being used to synchronize access to the data</div><div><p></p></div><div>to deal with it, programming languages choose different approaches:</div><div>, abandon concurrency altogether; make single threaded programs</div><div>, implement complicated and error prone lock mechanisms</div><div>, abandon mutability like in pure functional programming; but since mutability is necessary any way,</div><div>	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used</div><div>	<a href='https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples'>https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples</a></div><div>	<a href='https://clojure-doc.org/articles/language/concurrency_and_parallelism/'>https://clojure-doc.org/articles/language/concurrency_and_parallelism/</a></div><div>	any how, the lack of direct mutability, and the need for aggressive garbage collection,</div><div>		means that functional programming is not an efficient method</div><div>, use the approach taken by Pony <a href='https://www.ponylang.io/'>https://www.ponylang.io/</a></div><div>	it controls aliasing (sharing) and mutability, using reference capabilities</div><div>	Pony's approach introduces many complexities, especially when dealing with generics</div><div>	i think the main reason for its complexities is that even class fields have reference capabilities</div><div>, use actors</div><div><p></p></div><div>in Jina:</div><div>, numbers are small and have fixed size, so they will always be copied into variables</div><div>, actors are opaque types and they also will always be copied into variables</div><div>, strings, arrays, maps, and records are immutable, and they are referenced by variables</div><div>	in sync parts of the program, they will be reference counted statically</div><div>	when captured in async functions, they will be reference counted dynamically</div><div>	so there is no need for garbage collection</div><div>, there are three mutable types: boxes, mutable arrays, mutable maps; they are referenced by variables</div><div>	in sync parts of the program, they will be reference counted statically</div><div>	when captured in async functions, they will be copied</div><div>	so we can't mutate the environment of an async function; all mutations will be synchronous</div><div><p></p></div><div>Jina compiles to C:</div><div><a href='https://yosefk.com/blog/c-as-an-intermediate-language.html'>https://yosefk.com/blog/c-as-an-intermediate-language.html</a></div><div><a href='https://wiki.c2.com/?CeeAsAnIntermediateLanguage'>https://wiki.c2.com/?CeeAsAnIntermediateLanguage</a></div><div><a href='https://github.com/dbohdan/compilers-targeting-c'>https://github.com/dbohdan/compilers-targeting-c</a></div>
<h2>2, syntax</h2><div>comment line (";" must be the first non'whitespace charactor on the line):</div><div>	; comment</div><div>comment at the end of a line:</div><div>	;; comment</div><div>comment block:</div><div>	;[comment]</div><div>	;[multi'line</div><div>	comment</div><div>	]</div><div><p></p></div><div>variable definition:</div><div>	v = ...</div><div>type annotation:</div><div>	v : T = ...</div><div>types can be treated like values which are their own subtypes</div><div><p></p></div><div>integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)</div><div>floating point numbers: F32, F64</div><div><p></p></div><div>box:</div><div>	b : !I32 = 1</div><div>mutate the data in box:</div><div>	b.set 2</div><div>note that !T is a subtype of T, so all operation for T is also valid on !T</div><div><p></p></div><div>strings are immutable, and encoded in UTF8</div><div>	s : String = "abc def"</div><div>one word string:</div><div>	'abc</div><div>string interpolation: "abc{x}"</div><div>array of strings:</div><div>	'[</div><div>	line1</div><div>	line2</div><div>	]</div><div>which is equivalent to:</div><div>	["line1", "line2"]</div><div><p></p></div><div>array:</div><div>	a : A Int = [1, 2, 3]</div><div>indexing:</div><div>	a_1</div><div>maps are like arrays, but indexed using strings instead of integers:</div><div>	m : M Int = ["a": 1, "b": 2, "c": 3]</div><div>when keys are one word strings, this can also be written as:</div><div>	[a: 1, b: 2, c: 3]</div><div>mutable array/map:</div><div>	a : A! Int = [1, 2, 3]</div><div>	a = A! Int .new()</div><div><p></p></div><div>records:</div><div>	r = (a: 1, b: 2, c: 3)</div><div>	r = (1, 2, c: 3)</div><div>to access an element:</div><div>	r.a</div><div>	r.1</div><div>records can be matched on smaller records:</div><div>	a, b = 1, 2, 3</div><div>taged fields can be matched on untaged ones, if the name of variables match:</div><div>	a, b = a: 1, b: 2</div><div><p></p></div><div>record extension:</div><div>	(a: 1, b: 2)..(c: 3, d: 4)</div><div>which can also be written as:</div><div>	(a: 1, b: 2). c: 3 d: 4</div><div>the above value behaves like (but is not exactly the same as):</div><div>	(a: 1, b: 2, c: 3, d: 4)</div><div>common fields are possible if the new field is a subtype of the old one (which will be masked):</div><div>	(a: Int, b: 2). a: 3 ;; behaves like (a: 3, b: 2) ;;</div><div><p></p></div><div>function:</div><div>	f : Func (A, B) C = { a : A, b : B | : C ... }</div><div>function call:</div><div>	f x y</div><div>which is equivalent to:</div><div>	f(x, y)</div><div><p></p></div><div>{f x y} can be written as: \\ f x y</div><div><p></p></div><div>if'else:</div><div>	if condition {...} {...}</div><div>	if condition {...} \\ if c {...} \\ if c {...} {...}</div><div><p></p></div><div>and or:</div><div>	True & False</div><div>	True \ False</div><div>which are equivalent to:</div><div>	True.and {False}</div><div>	True.or {False}</div><div><p></p></div><div>matching:</div><div>	match a {</div><div>		b : B | ...</div><div>		None | ...</div><div>	}</div><div><p></p></div><div>loops:</div><div>	loop { ... break ... }</div><div>	while {condition} { ... }</div><div>	for iterator { x | ... }</div><div>which is equivalent to:</div><div>	iterator.for'each { x | ... }</div><div><p></p></div><div>async function:</div><div>	{ a : A || ... }</div><div>actor:</div><div>	a = Actor.new B. x y</div><div>	a.do { b : B || ... }</div><div><p></p></div><div>modules are files containing definitions</div><div>to make a definition private, append an apostrophe to the end of its name</div><div>the file named "0" is the root module</div><div>the root module can contain the main function</div><div>to import definitions from other modules:</div><div>	C', f' = import "module/path/relative/to/current/directory"</div><div>	C: D', f' = import "module/path/relative/to/current/directory"</div><div>	m' = import "/module/path/relative/to/project/root"</div><div>	m' = import "//hostname/package name including major version/module/path"</div><div><p></p></div><div>enum:</div><div>	Bool = [True, False]</div><div>"C?" is a shortcut for "[C, None]"</div><div><p></p></div><div>class:</div><div>	C = (</div><div>		a: A,</div><div>		b: B,</div><div>		new: { a : A | : C</div><div>			b = ...</div><div>			C. a: a b: b</div><div>		},</div><div>		m: { self, x : X | : Y</div><div>			...</div><div>		}</div><div>	)</div><div>creating an instance:</div><div>	i = C. a: x b: y</div><div>when calling a method, the "self" argument is skiped:</div><div>	i.m x</div><div><p></p></div><div>subclassing:</div><div>S = C. e: E</div><div><p></p></div><div>generics:</div><div>G = { p : P | a: p, b: B }</div>
<h2>3, graphics</h2><div>software rendering gives us a lot more flexibility,	because we won't be limited by a hardware implementation,</div><div>	with triangle only rasterization, isolated shader programs, and fixed size buffers</div><div>GPU equivalent performance can be achieved using SIMD (<a href='https://en.wikipedia.org/wiki/SIMD'>https://en.wikipedia.org/wiki/SIMD</a>)</div><div><a href='https://www.quora.com/What-is-the-main-difference-between-SIMD-and-GPU'>https://www.quora.com/What-is-the-main-difference-between-SIMD-and-GPU</a></div><div><a href='https://stackoverflow.com/questions/27333815/cpu-simd-vs-gpu-simd'>https://stackoverflow.com/questions/27333815/cpu-simd-vs-gpu-simd</a></div><div><a href='https://en.wikipedia.org/wiki/Vector_processor'>https://en.wikipedia.org/wiki/Vector_processor</a></div><div><a href='https://en.wikipedia.org/wiki/RISC-V#Vector_set'>https://en.wikipedia.org/wiki/RISC-V#Vector_set</a></div><div><p></p></div><div>graphical objects are made of primitives; each primitive has a specific algorithm for rasterization</div><div>2d primitives: point, line, curve, triangle, curved area</div><div>3d objects made of flat surfaces will be broken up into triangles</div><div>3d objects made of curved surfaces can be broken up into a number of primitive 3d surfaces,</div><div>	which can be easily projected to 2d</div><div><a href='https://en.wikipedia.org/wiki/Quadric'>https://en.wikipedia.org/wiki/Quadric</a></div><div>also interpolation is a good method for amorphous surfaces</div><div><p></p></div><div>2d objects will be rasterized into pixels (a pixel is a coordinate plus a color value)</div><div>then these rasterized objects will be drawn in the framebuffer,</div><div>	in layers over each other (in an overlay on top of all 3d objects)</div><div>rasterizing 3d objects, produces an array of fragments</div><div>	a fragment, besides color, contains a normal and a depth</div><div>when creating the pixels of the framebuffer from the fragments,</div><div>	the normals are used for lighting, and the depths are used for z'buffer</div><div><p></p></div><div>graphical objects are of 2 kinds:</div><div>, those which we know will remain unchanged the next time we want to draw to the framebuffer</div><div>	these objects are first rasterized into memory, then we copy it into framebuffer</div><div>, those which we know will be changed (scaled, rotated, moved in z direction),</div><div>	the next time we want to draw to the framebuffer (which happens a lot for animations with high frame rate)</div><div>	these objects will be drawn directly to the framebuffer</div><div>(framebuffer uses double buffering and v'sync)</div><div>note that if an object just moves in x'y plane (without rotation), the cached rasterization is still useful</div><div>	for 2d objects we simply add a constant to the position of all pixels</div><div>	for 3d objects we may additionally want to recompute the lighting of pixels from fragments</div><div><p></p></div><div>data structure for graphical objects:</div><div>, primitives</div><div>, material</div><div>, cached rasterization (can be none)</div><div><p></p></div><div>with a scene graph we can have fine grained graphical objects which can be combined easily</div><div><p></p></div><div><a href='https://en.wikipedia.org/wiki/Midpoint_circle_algorithm'>https://en.wikipedia.org/wiki/Midpoint_circle_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm'>https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</a></div><div><a href='http://members.chello.at/~easyfilter/bresenham.html'>http://members.chello.at/~easyfilter/bresenham.html</a></div><div><a href='https://nothings.org/gamedev/rasterize/'>https://nothings.org/gamedev/rasterize/</a></div><div><a href='https://magcius.github.io/xplain/article/'>https://magcius.github.io/xplain/article/</a></div><div><a href='https://en.wikipedia.org/wiki/Stencil_buffer'>https://en.wikipedia.org/wiki/Stencil_buffer</a></div><div><a href='https://www.scratchapixel.com'>https://www.scratchapixel.com</a></div><div><a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF'>https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF</a></div></body></html>