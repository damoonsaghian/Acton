
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Rustic</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Rustic'><h1>Rustic</h1></a>
<h2>1, Rustic</h2><div>Rustic is a programming language, based on actors and ownership mechanism</div><div><p></p></div><div>memory management:</div><div>, in synchronous parts, it can be done statically (no need for a garbage collector)</div><div>	<a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div>	<a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div>, in asynchronous parts, use actors</div><div>	actor variables actually hold an ID, and thus can easily be copied across async parts of the program</div><div>	this implies that an ID can refer to a deallocated actor</div><div>	when we send a message to a deallocated actor, it just does nothing</div><div><a href='https://riker.rs/hierarchy/'>https://riker.rs/hierarchy/</a></div><div><a href='https://crates.io/crates/aurum_actors'>https://crates.io/crates/aurum_actors</a></div><div>	<a href='https://docs.rs/aurum_actors/0.0.1/aurum_actors/#forgeable-references'>https://docs.rs/aurum_actors/0.0.1/aurum_actors/#forgeable-references</a></div><div>	<a href='https://docs.rs/aurum_actors/0.0.1/aurum_actors/core/index.html#sending-messages'>https://docs.rs/aurum_actors/0.0.1/aurum_actors/core/index.html#sending-messages</a></div><div><a href='https://github.com/elfo-rs/elfo'>https://github.com/elfo-rs/elfo</a></div><div>	<a href='https://docs.rs/elfo/0.1.19/elfo/struct.Addr.html'>https://docs.rs/elfo/0.1.19/elfo/struct.Addr.html</a></div><div>	<a href='https://github.com/elfo-rs/elfo/blob/master/elfo/examples/usage.rs'>https://github.com/elfo-rs/elfo/blob/master/elfo/examples/usage.rs</a></div><div><a href='https://docs.rs/acto/0.1.0/acto/struct.ActorId.html'>https://docs.rs/acto/0.1.0/acto/struct.ActorId.html</a></div><div>	<a href='https://github.com/Actyx/acto/blob/master/examples/pingpong.rs'>https://github.com/Actyx/acto/blob/master/examples/pingpong.rs</a></div><div><a href='https://github.com/Xudong-Huang/may_actor'>https://github.com/Xudong-Huang/may_actor</a></div><div><p></p></div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, thereâ€™s no mechanism being used to synchronize access to the data</div><div><p></p></div><div>to deal with it, programming languages choose different approaches:</div><div>, abandon concurrency altogether; make single threaded programs</div><div>, implement complicated and error prone lock mechanisms</div><div>, abandon mutability like in pure functional programming; but since mutability is necessary any way,</div><div>	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used</div><div>	<a href='https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples'>https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples</a></div><div>	<a href='http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types'>http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types</a></div><div>	any how, lack of direct mutability, and the need for aggressive garbage collection,</div><div>		means that functional programming is not an efficient method</div><div>, use the approach taken by Pony <a href='https://www.ponylang.io/'>https://www.ponylang.io/</a></div><div>	it doesn't abandon aliasing (sharing) nor mutability, instead it controls them using reference capabilities</div><div>	Pony's approach introduces many complexities, especially when dealing with generics</div><div>	i think the main reason for its complexities is that even class fields have reference capabilities</div><div><p></p></div><div>types show us what we can do with the data, ie which operations are valid</div><div>the class hierarchy design, like the one in Java, is problematic</div><div>	<a href='http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html'>http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html</a></div><div>also the problem of covariance for generic types, has its root in this problem</div><div>	<a href='https://en.wikipedia.org/wiki/Wildcard_(Java)'>https://en.wikipedia.org/wiki/Wildcard_(Java)</a></div><div>i think this problem is also the motivation for dynamic typing (another bad design)</div><div>the right way:</div><div>, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes</div><div>, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes</div>
<h2>2, syntax</h2><div>single'line comment:</div><div>	; comment</div><div>multi'line comment:</div><div>	;</div><div>	multi'line</div><div>	comment</div><div>	;</div><div>or:</div><div>	;; multi'line</div><div>	comment</div><div>	;</div><div><p></p></div><div>variable definition:</div><div>	v = 1</div><div>private variables:</div><div>	v' = 1</div><div><p></p></div><div>symbols: 'a '123</div><div>UTF-8 string (an array of UTF-8 symbols): "abc"</div><div>string interpolation: "a {b}"</div><div><p></p></div><div>tuples: (1, 2, 3)</div><div>use matching to access the contained items</div><div>	x, y, z = 1, 2, 3</div><div>tuple can be matched on sub'tuples:</div><div>	x, y = 1, 2, 3</div><div>named tuples: (x: 1, y: 2, z: 3)</div><div>named tuples can be matched on tuples if the name of variables match:</div><div>	x, y = x: 1, y: 2</div><div>we can't have a tuple with only one element, but a named tuple with only one element is possible</div><div><p></p></div><div>arrays: [1, 2, 3]</div><div>empty array:</div><div>	x :[Int] = []</div><div>indexing: x_1</div><div>maps with symbols as keys:</div><div>	[a: 1, b: 2, c: 3]</div><div>maps with variables as keys:</div><div>	[a : 1, b : 2, c : 3]</div><div>empty map:</div><div>	x :[Char, Int] = []</div><div><p></p></div><div>function:</div><div>{ x, y -&gt; ... }</div><div><p></p></div><div>actors:</div><div>a = Actor B(x)</div><div>a.do { b -&gt; ... }</div><div><p></p></div><div>function call:</div><div>f x y</div><div>which is equivalent to:</div><div>f(x, y)</div><div><p></p></div><div>{f x y} can be written as: | f x y</div><div><p></p></div><div>if'else:</div><div>if condition {...} {...}</div><div>if condition {...} | if c {...} {...} | if c {...} {...}</div><div><p></p></div><div>and or:</div><div>'true & {'false}</div><div>'true \ {'false}</div><div><p></p></div><div>matching:</div><div>	match x {</div><div>		x :X -&gt; ...</div><div>		x :'nil -&gt; ...</div><div>	}</div><div>though in this simple case there is a shortcut: x?</div><div><p></p></div><div>loops:</div><div>	loop {...break...}</div><div>while {condition} { ... }</div><div>	for iterator { x -&gt; ... }</div><div>which is equivalent to:</div><div>	iterator.for'each { x -&gt; ... }</div><div><p></p></div><div>modules are made of classes, functions and constants</div><div>the file named "0" is the root module</div><div>the root module can contain the main function</div><div><p></p></div><div>c :Int = 1</div><div><p></p></div><div>f = { x :X, y :Y -&gt; :Z</div><div>	...</div><div>}</div><div><p></p></div><div>import classes, functions and constants from other modules:</div><div>C', f' = import "module/path/relative/to/current/directory"</div><div>C', f: ff' = import "module/path/relative/to/current/directory"</div><div>C', f' = import "/module/path/relative/to/project/root"</div><div>C', f' = import "//package'name'majorVersionNumber/module/path"</div><div><p></p></div><div>class:</div><div>C = class [</div><div>	f1: F1,</div><div>	f2: F2,</div><div>	new: { f1 :F1 -&gt;</div><div>		self.f2 = ...</div><div>	},</div><div>	m1: { a :A -&gt; :R</div><div>		self.m2()</div><div>	},</div><div>	m2: { -&gt;</div><div>		...</div><div>	}</div><div>]</div><div><p></p></div><div>calling a method:</div><div>	o.m a</div><div>mutating a field:</div><div>	o.f = ...</div><div><p></p></div><div>generic class:</div><div>C(t) { ... }</div><div><p></p></div><div>type alias:</div><div>	T := (T1, T2)</div><div>	T := T1(T2)</div><div>symbols and numbers are actually their own types:</div><div>	's :'s</div><div>	1 :1</div><div>enums:</div><div>	Bool := 'true + 'false</div><div>"C?" is a shortcut for "C + 'nil"</div><div><p></p></div><div>interfaces are classes without constructors:</div><div>	I = interface [f1: F1, f2: F2] {</div><div>		m1: { ... },</div><div>		m2: { ... }</div><div>	}</div><div>defining a class which implements interfaces I1 and I2:</div><div>	C :: I1 + I2 = class { ... }</div>
<h2>3, graphics</h2><div>software rendering gives us a lot more flexibility,	because we won't be limited by a hardware implementation,</div><div>	with triangle only rasterization, isolated shader programs, and fixed size buffers</div><div>GPU equivalent performance can be achieved using SIMD (<a href='https://en.wikipedia.org/wiki/SIMD'>https://en.wikipedia.org/wiki/SIMD</a>)</div><div><a href='https://www.quora.com/What-is-the-main-difference-between-SIMD-and-GPU'>https://www.quora.com/What-is-the-main-difference-between-SIMD-and-GPU</a></div><div><a href='https://stackoverflow.com/questions/27333815/cpu-simd-vs-gpu-simd'>https://stackoverflow.com/questions/27333815/cpu-simd-vs-gpu-simd</a></div><div><a href='https://en.wikipedia.org/wiki/Vector_processor'>https://en.wikipedia.org/wiki/Vector_processor</a></div><div><a href='https://en.wikipedia.org/wiki/RISC-V#Vector_set'>https://en.wikipedia.org/wiki/RISC-V#Vector_set</a></div><div><p></p></div><div>graphical objects are made of primitives; each primitive has a specific algorithm for rasterization</div><div>2d primitives: point, line, curve, triangle, curved area</div><div>3d objects made of flat surfaces will be broken up into triangles</div><div>3d objects made of curved surfaces can be broken up into a number of primitive 3d surfaces,</div><div>	which can be easily projected to 2d</div><div><a href='https://en.wikipedia.org/wiki/Quadric'>https://en.wikipedia.org/wiki/Quadric</a></div><div>also interpolation is a good method for amorphous surfaces</div><div><p></p></div><div>2d objects will be rasterized into pixels (a pixel is a coordinate plus a color value)</div><div>then these rasterized objects will be drawn in the framebuffer,</div><div>	in layers over each other (in an overlay on top of all 3d objects)</div><div>rasterizing 3d objects, produces an array of fragments</div><div>	a fragment, besides color, contains a normal and a depth</div><div>when creating the pixels of the framebuffer from the fragments,</div><div>	the normals are used for lighting, and the depths are used for z'buffer</div><div><p></p></div><div>graphical objects are of 2 kinds:</div><div>, those which we know will remain unchanged the next time we want to draw to the framebuffer</div><div>	these objects are first rasterized into memory, then we copy it into framebuffer</div><div>, those which we know will be changed (scaled, rotated, moved in z direction),</div><div>	the next time we want to draw to the framebuffer (which happens a lot for animations with high frame rate)</div><div>	these objects will be drawn directly to the framebuffer</div><div>(framebuffer uses double buffering and v'sync)</div><div>note that if an object just moves in x'y plane (without rotation), the cached rasterization is still useful</div><div>	for 2d objects we simply add a constant to the position of all pixels</div><div>	for 3d objects we may additionally want to recompute the lighting of pixels from fragments</div><div><p></p></div><div>data structure for graphical objects:</div><div>, primitives</div><div>, material</div><div>, cached rasterization (can be none)</div><div><p></p></div><div>with a scene graph we can have fine grained graphical objects which can be combined easily</div><div><p></p></div><div><a href='https://en.wikipedia.org/wiki/Midpoint_circle_algorithm'>https://en.wikipedia.org/wiki/Midpoint_circle_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm'>https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</a></div><div><a href='http://members.chello.at/~easyfilter/bresenham.html'>http://members.chello.at/~easyfilter/bresenham.html</a></div><div><a href='https://nothings.org/gamedev/rasterize/'>https://nothings.org/gamedev/rasterize/</a></div><div><a href='https://magcius.github.io/xplain/article/'>https://magcius.github.io/xplain/article/</a></div><div><a href='https://en.wikipedia.org/wiki/Stencil_buffer'>https://en.wikipedia.org/wiki/Stencil_buffer</a></div><div><a href='https://www.scratchapixel.com'>https://www.scratchapixel.com</a></div><div><a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF'>https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF</a></div></body></html>