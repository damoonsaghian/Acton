
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Acton</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Acton'><h1>Acton</h1></a>
<h2>1, Acton</h2><div>Acton is a programming language, based on actors and ownership mechanism</div><div><p></p></div><div>we can use mutable borrow (!T) and immutable borrow (&T) to access data synchronously</div><div>for asynchronous access we use actors</div><div><a href='https://riker.rs/hierarchy/'>https://riker.rs/hierarchy/</a></div><div><a href='https://crates.io/crates/aurum_actors'>https://crates.io/crates/aurum_actors</a></div><div>  <a href='https://docs.rs/aurum_actors/0.0.1/aurum_actors/#forgeable-references'>https://docs.rs/aurum_actors/0.0.1/aurum_actors/#forgeable-references</a></div><div>  <a href='https://docs.rs/aurum_actors/0.0.1/aurum_actors/core/index.html#sending-messages'>https://docs.rs/aurum_actors/0.0.1/aurum_actors/core/index.html#sending-messages</a></div><div><a href='https://github.com/elfo-rs/elfo'>https://github.com/elfo-rs/elfo</a></div><div>  <a href='https://docs.rs/elfo/0.1.19/elfo/struct.Addr.html'>https://docs.rs/elfo/0.1.19/elfo/struct.Addr.html</a></div><div>  <a href='https://github.com/elfo-rs/elfo/blob/master/elfo/examples/usage.rs'>https://github.com/elfo-rs/elfo/blob/master/elfo/examples/usage.rs</a></div><div><a href='https://docs.rs/acto/0.1.0/acto/struct.ActorId.html'>https://docs.rs/acto/0.1.0/acto/struct.ActorId.html</a></div><div>  <a href='https://github.com/Actyx/acto/blob/master/examples/pingpong.rs'>https://github.com/Actyx/acto/blob/master/examples/pingpong.rs</a></div><div><a href='https://github.com/Xudong-Huang/may_actor'>https://github.com/Xudong-Huang/may_actor</a></div><div>actor variables actually hold an ID, and thus can easily be copied across async parts of the program</div><div>this implies that an ID can refer to a deallocated actor</div><div>when we send a message to a deallocated actor, it just does nothing</div><div><p></p></div><div>Acton compiles to Rust line by line</div><div>so Rust's error messages remain useful, and making a converter in the future will be easy</div><div><a href='https://arzg.github.io/lang/'>https://arzg.github.io/lang/</a></div><div><a href='https://github.com/alilleybrinker/langs-in-rust'>https://github.com/alilleybrinker/langs-in-rust</a></div><div><a href='https://github.com/koto-lang/koto'>https://github.com/koto-lang/koto</a></div><div><a href='https://github.com/PistonDevelopers/dyon'>https://github.com/PistonDevelopers/dyon</a></div><div><a href='https://github.com/jfecher/ante'>https://github.com/jfecher/ante</a></div><div><p></p></div><div>Rust makes bad programming hard, and good programming fun</div><div>Rust does not hide inherent complexity, in fact it bolds it, so we can see it, and avoid it</div><div>by inherent complexity i mean a complexity which can not be abstracted away completely</div><div>  ie if we try to hide it, it will re_emerge somewhere else</div><div>in fact, hiding inherent complexity usually leads to choosing the wrong approach</div><div><a href='https://fasterthanli.me/articles/a-half-hour-to-learn-rust'>https://fasterthanli.me/articles/a-half-hour-to-learn-rust</a></div><div><p></p></div><div>maybe the most prominent example of an inherent complexity in programming is memory management</div><div>rather than hiding it behind a garbage collector, Rust uses ownership mechanism</div><div>  which allows Rust to eliminate the need for a garbage collector in synchronous programming</div><div><a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div><a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div>to also eliminate garbage collection in asynchronous parts, we use actors</div><div><p></p></div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, thereâ€™s no mechanism being used to synchronize access to the data</div><div><p></p></div><div>to deal with it, programming languages choose different approaches:</div><div>, abandon concurrency altogether; make single threaded programs</div><div>, implement complicated and error prone lock mechanisms</div><div>, abandon mutability like in pure functional programming; but since mutability is necessary any way,</div><div>  a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used</div><div>  <a href='https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples'>https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples</a></div><div>  <a href='http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types'>http://clojure-doc.org/articles/language/concurrency_and_parallelism.html#clojure-reference-types</a></div><div>  any how, lack of direct mutability, and the need for aggressive garbage collection,</div><div>  means that functional programming is not an efficient method</div><div>, use the approach taken by Pony <a href='https://www.ponylang.io/'>https://www.ponylang.io/</a></div><div>  it doesn't abandon aliasing (sharing) nor mutability, instead it controls them using reference capabilities</div><div>  Pony's approach introduces many complexities, especially when dealing with generics</div><div>  i think the main reason for its complexities is that even class fields have reference capabilities</div><div><p></p></div><div>the right approach is to use ownership mechanism (as is done in Rust):</div><div>, any resource has an owner</div><div>, borrows must have a lifetime less than the owner</div><div>, mutable borrow has exclusive access to the resource, during its lifetime</div><div><p></p></div><div>static data (functions, structs, constants): no problem, copy or share by reference</div><div>dynamic data:</div><div>, if data is small we usually put it on stack; so we don't share it across the program, we copy it</div><div>, if data is big we put it on the heap and make references to it</div><div>  if data is immutable we just have to manage its lifetime,</div><div>    either statically (using "&"), or dynamically (using "Arc")</div><div>  but if data is mutable we have to check if the read_write_lock pattern is fulfilled, using "&mut" or "Actor"</div><div>  "Mutex" or "RwLock" check read_write_lock pattern at runtime, and make the program to panic, if it's failed</div><div><p></p></div><div>owner can:</div><div>, access and mutate the resource</div><div>, lend the resource to a reference</div><div>, hand over the ownership (move), or deallocate resource</div><div>but during a lend, owner can't:</div><div>, mutate the resource</div><div>, mutably lend resource to another reference</div><div>, hand over the ownership (move), or deallocate resource</div><div>and during a mutable lend, owner can't even access the resource</div><div><p></p></div><div>immutable (and thus sharable) references can:</div><div>, access borrowed resource</div><div>, immutably lend resource to other references</div><div>mutable (and thus exclusive) reference can:</div><div>, access and mutate the resource</div><div>, mutably lend resource to another reference</div><div>, immutably lend resource, but during this lending, they can't mutate it</div><div>  just like when an owner immutably lends its resource</div><div><p></p></div><div>during shared borrow (immutable borrow) no one owns the data</div><div>  so even the original owner can't change it</div><div>during mutable borrow the (unique) borrower owns it</div><div>so mutable borrow is actually a temporary transfer of ownership</div><div><p></p></div><div>types show us what we can do with the data, ie which operations are valid</div><div>the class hierarchy design, like the one in Java, is problematic</div><div>  <a href='http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html'>http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html</a></div><div>also the problem of covariance for generic types, has its root in this problem</div><div>  <a href='https://en.wikipedia.org/wiki/Wildcard_(Java)'>https://en.wikipedia.org/wiki/Wildcard_(Java)</a></div><div>i think this problem is also the motivation for dynamic typing (another bad design)</div><div>the right way:</div><div>, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes</div><div>, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes</div><div><p></p></div><div>some of the subtleties of Rust's syntax:</div><div><p></p></div><div>s: String -&gt; &s: &String -&gt; &s[..]: &str</div><div>v: Vec&lt;T&gt; -&gt; &v: &Vec&lt;T&gt; -&gt; &v[..]: &[T]</div><div>&str and &[T] are slices; str and [T] are unsized types</div><div>slicing is like borrowing from an unsized type</div><div>since the slice contains the size, the lending type itself doesn't need to have a definite size</div><div><p></p></div><div>x = a[i] -&gt; this is possible if the elements of "a" are copy (cause moving out of collections is not possible)</div><div>x = &a[i] -&gt; this is for the case when the elements are not copy</div><div>x = a[i..j] -&gt; this is always invalid</div><div>x = &a[i..j] -&gt; slicing</div><div><p></p></div><div>auto ref/deref for self in method calls:</div><div>  compiler inserts as many * or & as necessary to get it right</div><div><p></p></div><div>deref coercion:</div><div>, &T -&gt; &U when T: Deref&lt;Target=U&gt;</div><div>, &mut T -&gt; &U when T: Deref&lt;Target=U&gt;</div><div>, &mut T -&gt; &mut U when T: DerefMut&lt;Target=U&gt;</div><div>examples:</div><div>  &&i32 -&gt; &i32 because &i32: Deref&lt;Target=i32&gt;</div><div>  &String -&gt; &str because String: Deref&lt;Target=str&gt;</div><div>  &Vec&lt;T&gt; -&gt; &[T] because Vec&lt;T&gt;: Deref&lt;Target=[T]&gt;</div><div>  &Arc&lt;T&gt; -&gt; &T because Arc&lt;T&gt;: Deref&lt;Target=T&gt;</div><div><a href='https://github.com/rust-lang/rfcs/blob/master/text/0241-deref-conversions.md'>https://github.com/rust-lang/rfcs/blob/master/text/0241-deref-conversions.md</a></div><div><p></p></div><div>arrays like tuples have fixed size and thus stored on stack</div><div>but since they are homogeneous (all elements are of the same type), they can be indexed at runtime</div><div>vectors and hash tables are homogeneous, varying sized collections</div><div><p></p></div><div>a closure is like an anonymous struct made of variables captured from environment,</div><div>  that is callable (implements Fn/FnMut/FnOnce trait)</div><div>so all closures are unique types, but they have traits in common</div><div>note that if we put a generic type parameter in the return type of a function,</div><div>  we have to provide the concrete type when we call the function</div><div>  thus we can't use generic type parameters to return a closure, we have to use "impl"</div><div><p></p></div><div>"fn(T1) -&gt; T2" is not an unsized type like "str", it's a function pointer</div><div><p></p></div><div>"x.m()" is method call syntax, which completely differs from "(x.m)()"</div><div><p></p></div><div>Rust libgccjit</div><div><p></p></div><div><a href='https://crates.io/crates/serde'>https://crates.io/crates/serde</a></div><div><a href='https://github.com/ron-rs/ron'>https://github.com/ron-rs/ron</a></div><div><p></p></div><div>math:</div><div>https://nalgebra.org/rustdoc/nalgebra/index.html</div><div>https://gitlab.com/ornamentist/un-algebra</div><div>https://github.com/rustsim/alga</div>
<h2>2, syntax</h2><div>single'line comment: //</div><div>multi'line comment: /* */</div><div><p></p></div><div>character: \a</div><div>UTF-8 string: "abc"</div><div><p></p></div><div>tuples:</div><div>1, 2, 3</div><div>tuple can match on sub'tuples:</div><div>match (1, 2, 3) {x, y -&gt; ...}</div><div>named tuples:</div><div>x: 1, y: 2, z: 3</div><div>named tuples can be matched on tuples if the name of variables match:</div><div>match (x: 1, y: 2) {x, y -&gt; ...}</div><div>we can't have a tuple with only one element, but we can have a named tuple with only one element</div><div><p></p></div><div>arrays:</div><div>[1, 2, 3]</div><div>an empty array:</div><div>x :: Array&lt;Int&gt; = []</div><div>indexing: x_1</div><div>maps:</div><div>[\a =&gt; 1, \b =&gt; 2, \c =&gt; 3]</div><div>an empty map:</div><div>x :: Map&lt;Char, Int&gt; = []</div><div>maps with strings as keys:</div><div>["a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3]</div><div>[a: 1, b: 2, c: 3]</div><div><p></p></div><div>variable definition:</div><div>x = 1</div><div>assignment:</div><div>x .= 1</div><div>x.a = 1</div><div><p></p></div><div>closure:</div><div>{x, y -&gt; ...}</div><div>move closure:</div><div>^{x, y -&gt; ...}</div><div><p></p></div><div>actors:</div><div>a = Actor B(x)</div><div>a.do {b -&gt; ...}</div><div><p></p></div><div>function call:</div><div>f(x, y)</div><div>f x, y</div><div>note that in nested function calls or tuples, inner expressions must all have parentheses</div><div>function call with a closures as the last arguments:</div><div>f x, y {...} {...}</div><div><p></p></div><div>{f x, y} can be written as: | f x, y</div><div><p></p></div><div>if else:</div><div>if condition {...} {...}</div><div>if condition {} | if c {} {}</div><div><p></p></div><div>and or:</div><div>True && {False}</div><div>True || {False}</div><div><p></p></div><div>match x {</div><div>  Some(a) -&gt; ...</div><div>  Nil -&gt; ...</div><div>}</div><div><p></p></div><div>loops:</div><div>loop {...break...}</div><div>while {condition} {...}</div><div>for iterator {x -&gt; ...}</div><div>which is equivalent to:</div><div>iterator.for'each {x -&gt; ...}</div><div><p></p></div><div>in modules we can only have static definitions</div><div>ie we can only define types, functions, and constants which can be computed at compile'time</div><div>in a module, definitions marked with an apostrophe, are private</div><div>the file called "0.cr" is the root module</div><div>the root module can contain the "main" function</div><div><p></p></div><div>c :: Int = 1</div><div><p></p></div><div>f :: &X, &Y -&gt; () = {x, y -&gt;</div><div>  ...</div><div>}</div><div><p></p></div><div>'M = import "module/path/relative/to/current/directory"</div><div>'a, 'B, 'c = import "module/path/relative/to/current/directory"</div><div>'x = import "module/path/relative/to/current/directory" .a</div><div>(a: 'x, B: 'Y, c: 'c) = M</div><div>'x, 'Y, 'c = M .a, .B, .c</div><div>'M = import "/module/path/relative/to/project/root"</div><div>'M = import "//package'name'majorVersionNumber/module/path"</div><div><p></p></div><div>struct:</div><div>:: S(a: A, b: B)</div><div>:: S(A, B)</div><div>private struct:</div><div>:: 'S(a: A, b: B)</div><div><p></p></div><div>enum:</div><div>:: E</div><div>:| X(a: A, b: B)</div><div>:| Y</div><div><p></p></div><div>generic struct:</div><div>:: S[a](a, B)</div><div><p></p></div><div>type alias:</div><div>:: A = (B, C)</div><div>:: A = B[C]</div><div><p></p></div><div>:: T {</div><div>  m :: &, &X -&gt; Y = {self, x -&gt; ...}</div><div>  n :: ! -&gt; () = {self -&gt; ...}</div><div>}</div><div><p></p></div><div>trait:</div><div>:: t {</div><div>  m :: &, &A -&gt; B</div><div>  n :: ! -&gt; ()</div><div>}</div><div>implementing a trait:</div><div>:: S t {</div><div>  ...</div><div>}</div>
<h2>3, graphics</h2><div>software rendering gives us a lot more flexibility,</div><div>  because we won't be limited by a hardware implementation,</div><div>  with triangle only rasterization, isolated shader programs, and fixed size buffers</div><div>GPU equivalent performance can be achieved using SIMD (<a href='https://en.wikipedia.org/wiki/SIMD'>https://en.wikipedia.org/wiki/SIMD</a>)</div><div><p></p></div><div>graphical objects are made of primitives</div><div>  each primitive has a specific algorithm for rasterization</div><div>2d primitives: point, line, curve, triangle, curved area</div><div>3d objects made of flat surfaces will be broken up into triangles</div><div>3d objects made of curved surfaces can be broken up into a number of primitive 3d surfaces,</div><div>  which can be easily projected to 2d</div><div><a href='https://en.wikipedia.org/wiki/Quadric'>https://en.wikipedia.org/wiki/Quadric</a></div><div>also interpolation is a good method for amorphous surfaces</div><div><p></p></div><div>2d objects will be rasterized into pixels (a pixel is a coordinate plus a color value)</div><div>then these rasterized objects will be drawn in the framebuffer,</div><div>  in layers over each other (in an overlay on top of all 3d objects)</div><div>rasterizing 3d objects, produces an array of fragments</div><div>  a fragment, besides color, contains a normal and a depth</div><div>when creating the pixels of the framebuffer from the fragments,</div><div>  the normals are used for lighting, and the depths are used for z'buffer</div><div><p></p></div><div>graphical objects are of 2 kinds:</div><div>, those which we know will remain unchanged the next time we want to draw to the framebuffer</div><div>  these objects are first rasterized into memory, then we copy it into framebuffer</div><div>, those which we know will be changed (scaled, rotated, moved in z direction),</div><div>  the next time we want to draw to the framebuffer (which happens a lot for animations with high frame rate)</div><div>  these objects will be drawn directly to the framebuffer</div><div>(framebuffer uses double buffering and v'sync)</div><div>note that if an object just moves in x'y plane (without rotation), the cached rasterization is still useful</div><div>  for 2d objects we simply add a constant to the position of all pixels</div><div>  for 3d objects we may additionally want to recompute the lighting of pixels from fragments</div><div><p></p></div><div>data structure for graphical objects:</div><div>, primitives</div><div>, material</div><div>, cached rasterization (can be none)</div><div><p></p></div><div>with a scene graph we can have fine grained graphical objects which can be combined easily</div><div><p></p></div><div><a href='https://en.wikipedia.org/wiki/Midpoint_circle_algorithm'>https://en.wikipedia.org/wiki/Midpoint_circle_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm'>https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</a></div><div><a href='http://members.chello.at/~easyfilter/bresenham.html'>http://members.chello.at/~easyfilter/bresenham.html</a></div><div><a href='https://nothings.org/gamedev/rasterize/'>https://nothings.org/gamedev/rasterize/</a></div><div><a href='https://magcius.github.io/xplain/article/'>https://magcius.github.io/xplain/article/</a></div><div><a href='https://en.wikipedia.org/wiki/Stencil_buffer'>https://en.wikipedia.org/wiki/Stencil_buffer</a></div><div><a href='https://www.scratchapixel.com'>https://www.scratchapixel.com</a></div><div><a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF'>https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF</a></div><div><p></p></div><div><a href='https://github.com/rust-windowing/winit'>https://github.com/rust-windowing/winit</a></div><div><a href='https://github.com/kas-gui/kas'>https://github.com/kas-gui/kas</a></div><div><a href='https://github.com/sebcrozet/kiss3d'>https://github.com/sebcrozet/kiss3d</a></div><div><a href='https://github.com/three-rs/three'>https://github.com/three-rs/three</a></div><div><a href='https://crates.io/crates/rust-3d'>https://crates.io/crates/rust-3d</a></div><div><a href='https://github.com/38/plotters'>https://github.com/38/plotters</a></div><div><a href='https://github.com/rustsim/nphysics'>https://github.com/rustsim/nphysics</a></div><div><p></p></div><div>mono'space fonts:</div><div>  wide characters are forced to squeeze</div><div>  narrow characters are forced to stretch</div><div>  uppercase letters look skinny next to lowercase</div><div>  bold characters donâ€™t have enough room</div><div>proportional font for code:</div><div>  generous spacing</div><div>  large punctuation</div><div>  and easily distinguishable characters</div><div>  while allowing each character to take up the space that it needs</div><div><a href='http://input.fontbureau.com/info/'>http://input.fontbureau.com/info/</a></div><div>for proportional fonts, we can't use spaces for text alignment</div><div>elastic tabstops may help: <a href='http://nickgravgaard.com/elastic-tabstops/'>http://nickgravgaard.com/elastic-tabstops/</a></div><div>but i think, text alignment is a bad idea, in general</div>
<h2>4, GUI</h2><div>implementing a complete GUI toolkit is a lot of work</div><div>existing ones (like GTK) are single threaded</div><div>thus we can't access GTK widgets (and data structures containing them), from inside actors</div><div>solution:</div><div><a href='https://gtk-rs.org/docs/glib/source/fn.idle_add.html'>https://gtk-rs.org/docs/glib/source/fn.idle_add.html</a></div><div><a href='https://docs.rs/fragile/1.0.0/fragile/struct.Fragile.html'>https://docs.rs/fragile/1.0.0/fragile/struct.Fragile.html</a></div><div><a href='https://docs.rs/send_wrapper/0.4.0/send_wrapper/'>https://docs.rs/send_wrapper/0.4.0/send_wrapper/</a></div><div>we deal with Gobjects by wrapping them in a Gsend</div><div>Gsend embeds a Fragile which will be created in the GTK main thread (using "idle_add"),</div><div>  and then received (and put inside the Gsend) using a channel</div><div>Gsend.new gets a closure (instead of a Gobject value),</div><div>  the closure's return type is the type of the specific Gobject</div><div><p></p></div><div><a href='https://gtk-rs.org/'>https://gtk-rs.org/</a></div><div>gtksourceview4 webkit2gtk</div><div>poppler-glib goffice goocanvas</div></body></html>