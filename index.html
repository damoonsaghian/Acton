
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Jina</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Jina'><h1>Jina</h1></a>
<h2>1, Jina</h2><div>Jina is a programming language with sane memory management, actors, and a coherent syntax</div><div><p></p></div><div>Mahsa Jina Amini was a Kurdish girl whose tragic murder by the evil regime, started a revolution in Iran</div><div>at her funeral, these words were written on a stone above her grave:</div><div>	beloved Jina, you will not die, your name will become a code</div><div><p></p></div><div>memory management:</div><div>, in synchronous parts, it can be done at compile time</div><div>, in asynchronous parts, reference counting is used</div><div><a href='http://aardappel.github.io/lobster/memory_management.html'>http://aardappel.github.io/lobster/memory_management.html</a></div><div><a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div><a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div><p></p></div><div>in Jina:</div><div>, numbers are small and have fixed size, so they will always be copied into variables</div><div>, records have fixed size</div><div>	they will be copied into variables,	if they are small, and are stored in immutable variables</div><div>	otherwise they will be referenced by variables</div><div>, all other types (strings, arrays, maps, functions, ...) are referenced by variables</div><div>refernces will be reference counted if captured in async functions</div><div><p></p></div><div>actors are used to achieve lock'free concurrency</div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, thereâ€™s no mechanism being used to synchronize access to the data</div><div><p></p></div><div>to deal with it, programming languages choose different approaches:</div><div>, abandon concurrency altogether; make single threaded programs</div><div>, implement complicated and error prone lock mechanisms</div><div>, abandon mutability like in pure functional programming; but since mutability is necessary any way,</div><div>	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used</div><div>	<a href='https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples'>https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples</a></div><div>	<a href='https://clojure-doc.org/articles/language/concurrency_and_parallelism/'>https://clojure-doc.org/articles/language/concurrency_and_parallelism/</a></div><div>	any how, the lack of direct mutability, and the need for aggressive garbage collection,</div><div>		means that functional programming is not an efficient method</div><div>, use the approach taken by Pony <a href='https://www.ponylang.io/'>https://www.ponylang.io/</a></div><div>	it controls aliasing (sharing) and mutability, using reference capabilities</div><div>	Pony's approach introduces many complexities, especially when dealing with generics</div><div>	i think the main reason for its complexities is that even class fields have reference capabilities</div><div><p></p></div><div>in Jina mutable variables, when captured in async functions, will be copied</div><div>so we can't mutate the environment of an async function; all mutations will be synchronous</div><div><p></p></div><div>types show us what we can do with the data, ie which operations are valid</div><div>the class hierarchy designs (like the one in Java) is problematic</div><div>	<a href='http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html'>http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html</a></div><div>also it leads to the problem of generic types not being covariant</div><div>	<a href='https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)'>https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></div><div>i feel that this problem was the motivation behind dynamic typing (another bad design)</div><div>to solve this problem, some languages like Rust introduse two kind of types:</div><div>, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes</div><div>, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes</div><div><p></p></div><div>in Jina, the only difference between types and normal values, is that, types are not their own subtypes</div><div>as you will see, all the complexities of type systems, including the one mentioned above,</div><div>	will be naturally resolved in Jina</div><div><p></p></div><div>Jina compiles to GLib based C</div>
<h2>2, syntax</h2><div>comment line (";" must be the first non'whitespace charactor on the line):</div><div>	; comment</div><div>comment at the end of a line:</div><div>	;; comment</div><div>comment block:</div><div>	;[comment]</div><div>	;[multi'line</div><div>	comment</div><div>	]</div><div><p></p></div><div>variable definition:</div><div>	v = ...</div><div>type annotation:</div><div>	v : T = ...</div><div>	v :T = ...</div><div>mutable variable:</div><div>	v !T = ...</div><div>	v! = ...</div><div>assignment:</div><div>	v .= ...</div><div><p></p></div><div>integers: I8, I16, I32, I64, Int (which can be 32 or 64 depending on the system)</div><div>floating point numbers: F32, F64</div><div><p></p></div><div>strings are immutable, and encoded in UTF8</div><div>	s :String = "abc def"</div><div>one word string:</div><div>	'abc</div><div>string interpolation: "abc{x}"</div><div><p></p></div><div>array:</div><div>	a :Array(Int) = [1, 2, 3]</div><div>indexing:</div><div>	a_1</div><div>maps are like arrays, but indexed using strings instead of integers:</div><div>	m :Map(Int) = ["a": 1, "b": 2, "c": 3]</div><div>when keys are one word strings, this can also be written as:</div><div>	[a: 1, b: 2, c: 3]</div><div><p></p></div><div>array of strings:</div><div>	'[</div><div>		line1</div><div>			line2</div><div>	]</div><div>which is equivalent to:</div><div>	["line1", "\tline2"]</div><div><p></p></div><div>records:</div><div>	r = a: 1, b: 2, c: 3</div><div>	r :(Int, Int, c: Int) = 1, 2, c: 3</div><div>to access an element:</div><div>	r.a</div><div>	r.0</div><div>alternative syntax: # a: 1 b: 2 c: 3</div><div>records can be matched on smaller records:</div><div>	a, b = 1, 2, 3</div><div>taged fields can be matched on untaged ones, if the name of variables match:</div><div>	a, b = a: 1, b: 2</div><div><p></p></div><div>mutating a record:</div><div>	r! = a: 1, b: 2, c: 3</div><div>	r.a = 10</div><div><p></p></div><div>record extension:</div><div>	(a: 1, b: 2)..(c: 3, d: 4)</div><div>or:</div><div>	(a: 1, b: 2). (c: 3, d: 4)</div><div>the above behaves like:</div><div>	(a: 1, b: 2, c: 3, d: 4)</div><div>masking fields:</div><div>	(a: 1, b: 2). (b: 3, c: 4)</div><div>which behaves like:</div><div>	(a: 1, b: 3, c: 4)</div><div><p></p></div><div>function:</div><div>	f = { a :A , b :B | :C ... }</div><div>determining default values for parameters:</div><div>	f = { a :: 1 | :B ... }</div><div>function call:</div><div>	f x y</div><div>which is equivalent to:</div><div>	f(x, y)</div><div><p></p></div><div>note that each function has a unique type</div><div>but all functions implement the "Func(I, O)" interface ("I" being the input type, and "O" the output type)</div><div>why "Func" is an interface, and not a simple generic type like "Array" for example</div><div>because functions are contravariant in input types, and covariant in output types</div><div><a href='https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)'>https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></div><div><p></p></div><div>{ f x y } can be written as: \\ f x y</div><div><p></p></div><div>if'else:</div><div>	if condition {...} {...}</div><div>	if condition {...} \\ if c {...} \\ if c {...} {...}</div><div><p></p></div><div>and or:</div><div>	True & False</div><div>	True \ False</div><div>which are equivalent to:</div><div>	True .and {False}</div><div>	True .or {False}</div><div><p></p></div><div>matching:</div><div>	match a {</div><div>		Some. b | ...</div><div>		None | ...</div><div>	}</div><div><p></p></div><div>loops:</div><div>	loop { ... break ... }</div><div>	while {condition} { ... }</div><div>	for iterator { x | ... }</div><div>which is equivalent to:</div><div>	iterator.for'each { x | ... }</div><div><p></p></div><div>async function:</div><div>	af :Async(A) = { a :A || ... }</div><div>actor:</div><div>	a = Actor.new B.new(x, y)</div><div>	a.do { b :B || ... }</div><div><p></p></div><div>modules are files containing definitions</div><div>public definition are accessable from outside of the module: a' = ...</div><div>the file named "0.jina" is the root module</div><div>the root module can contain the main function</div><div>packages are directories containing a root module</div><div>to access a module or a package, just use its path relative to the package directory:</div><div>	m = ..module'or'package</div><div>	m = .."dir/module'or'package"</div><div>too access modules in packages (protocol can be gnunet, git or local):</div><div>	m = .."protocol://address'of'project'dir/dir/file"</div><div><p></p></div><div>class are records with methods (functions which their first argument is "self"):</div><div>	C = #</div><div>		a: A</div><div>		b:: B. 1 ; field with default value</div><div>		new: { a :A | :C</div><div>			b = ...</div><div>			a: a, b: b</div><div>		}</div><div>		m1: { self, x :X | :Y</div><div>			...</div><div>		}</div><div>		m2: { self! |</div><div>			...</div><div>		}</div><div>to make a field private, put an apostrophe at the start of its name</div><div>to create a subtype of a class all fields which are not their own subtypes must be masked by a value:</div><div>	i = S..(a: x, b: y)</div><div>	i = S. a: x b: y</div><div>	i = S.new a: x</div><div>when calling a method, the "self" argument is skiped:</div><div>	i.m x</div><div><p></p></div><div>interfaces:</div><div>	I = #</div><div>		m1: Func (self, x: X) Y</div><div>		m2:: { self! |</div><div>			; default implementation</div><div>		}</div><div>interface inheritance:</div><div>	I3 = I1. I2. # ...</div><div><p></p></div><div>a class that implements some interfaces:</div><div>	C :I1..I2 = # ...</div><div>to implement an interface privately:</div><div>	C :I' = # ...</div><div><p></p></div><div>in Jina, a GObject class translates to a (final) class "G" plus an interface "G'i"</div><div>the interface contains all the instance methods of the corresponding GObject class, plus a "base" method</div><div>	base: : Func self G</div><div>to implement "G'i":</div><div>	C :G'i = #</div><div>		base'field: G</div><div>		...</div><div>		base: { self | :G self.base'field }</div><div>		...</div><div>if the first field is of type "G", the "base" method will be automatically generated,</div><div>	no need to write it manually</div><div><p></p></div><div>generics:</div><div>	C = { X | ... }</div><div>generics bound by an interface:</div><div>	C = { X :I | ... }</div><div><p></p></div><div>enums:</div><div>	Bool = #</div><div>		True: Bool. 'true</div><div>		False: Bool. 'false</div><div>		...</div><div>	True = Bool.True</div><div>	False = Bool.False</div><div>"?A" is a shortcut for "Maybe(A)":</div><div>	Maybe = { X | #</div><div>		Some: Maybe(X). 'some X</div><div>		None: Maybe(X). 'none</div><div>		...</div><div>	}</div><div>	Some = { X | Maybe(X).Some }</div><div>	None = { X | Maybe(X).None }</div></body></html>